{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/toolkit/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/asserters.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/sortMarksByOccurences.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/buildMarksTree.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/nestLists.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/spanToPlainText.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/toPlainText.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/toolkit/src/types.ts"],"sourcesContent":["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // oxlint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n","import {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\nimport type {ToolkitNestedPortableTextSpan} from './types'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n","import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /\\s$/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (ToolkitTextNode | ToolkitNestedPortableTextSpan | ArbitraryTypedObject)[]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/react/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/components/list.tsx","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/components/marks.tsx","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/warnings.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/components/unknown.tsx","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/components/defaults.tsx","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/components/merge.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/react/src/react-portable-text.tsx"],"sourcesContent":["import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  // oxlint-disable-next-line no-console\n  console.warn(message)\n}\n","import type {PortableTextReactComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {JSX} from 'react'\n\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): JSX.Element => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextReactComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n): PortableTextReactComponents {\n  const {\n    block: _block,\n    list: _list,\n    listItem: _listItem,\n    marks: _marks,\n    types: _types,\n    ...rest\n  } = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from '@portabletext/toolkit'\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  LIST_NEST_MODE_HTML,\n  nestLists,\n  spanToPlainText,\n} from '@portabletext/toolkit'\nimport type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\nimport {type JSX, type ReactNode, useMemo} from 'react'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>): JSX.Element {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent],\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  function renderListItem(node: PortableTextListItemBlock, index: number, key: string) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: 'listStyle',\n        type: style,\n      })\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child,\n        index: childIndex,\n        isInline: true,\n        renderNode,\n      }),\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {\n        nodeType: 'mark',\n        type: markType,\n      })\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({\n      node,\n      index,\n      isInline,\n      renderNode,\n    })\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: 'block',\n      type: node._type,\n    })\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/schema/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/schema/src/compile-schema.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/schema/src/define-schema.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/schema/src/types.ts"],"sourcesContent":["import type {SchemaDefinition} from './define-schema'\nimport type {FieldDefinition, Schema} from './schema'\n\n/**\n * @public\n */\nexport function compileSchema(definition: SchemaDefinition): Schema {\n  const styles = (definition.styles ?? []).map((style) => ({\n    ...style,\n    value: style.name,\n  }))\n\n  const blockFields: Array<FieldDefinition> = []\n\n  if (definition.block?.fields) {\n    for (const field of definition.block.fields) {\n      if (\n        field.name === '_type' ||\n        field.name === '_key' ||\n        field.name === 'children' ||\n        field.name === 'markDefs' ||\n        field.name === 'style' ||\n        field.name === 'listItem' ||\n        field.name === 'level'\n      ) {\n        console.warn(\n          `\"${field.name}\" is a reserved field name on Portable Text blocks`,\n        )\n        continue\n      }\n\n      blockFields.push(field)\n    }\n  }\n\n  return {\n    block: {\n      name: definition.block?.name ?? 'block',\n      ...(blockFields.length > 0 ? {fields: blockFields} : {}),\n    },\n    span: {\n      name: 'span',\n    },\n    styles: !styles.some((style) => style.value === 'normal')\n      ? [{value: 'normal', name: 'normal', title: 'Normal'}, ...styles]\n      : styles,\n    lists: (definition.lists ?? []).map((list) => ({\n      ...list,\n      value: list.name,\n    })),\n    decorators: (definition.decorators ?? []).map((decorator) => ({\n      ...decorator,\n      value: decorator.name,\n    })),\n    annotations: (definition.annotations ?? []).map((annotation) => ({\n      ...annotation,\n      fields: annotation.fields ?? [],\n    })),\n    blockObjects: (definition.blockObjects ?? []).map((blockObject) => ({\n      ...blockObject,\n      fields: blockObject.fields ?? [],\n    })),\n    inlineObjects: (definition.inlineObjects ?? []).map((inlineObject) => ({\n      ...inlineObject,\n      fields: inlineObject.fields ?? [],\n    })),\n  }\n}\n","import type {BaseDefinition, FieldDefinition} from './schema'\n\n/**\n * @public\n */\nexport type SchemaDefinition = {\n  block?: {\n    name?: string\n    fields?: ReadonlyArray<FieldDefinition>\n  }\n  styles?: ReadonlyArray<StyleDefinition>\n  lists?: ReadonlyArray<ListDefinition>\n  decorators?: ReadonlyArray<DecoratorDefinition>\n  annotations?: ReadonlyArray<AnnotationDefinition>\n  blockObjects?: ReadonlyArray<BlockObjectDefinition>\n  inlineObjects?: ReadonlyArray<InlineObjectDefinition>\n}\n\n/**\n * @public\n * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.\n * @example\n * ```ts\n * import { defineSchema } from '@portabletext/editor'\n *\n * const schemaDefinition = defineSchema({\n *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],\n *  annotations: [{name: 'link'}],\n *  styles: [\n *    {name: 'normal'},\n *    {name: 'h1'},\n *    {name: 'h2'},\n *    {name: 'h3'},\n *    {name: 'blockquote'},\n *  ],\n *  lists: [],\n *  inlineObjects: [],\n *  blockObjects: [],\n * }\n * ```\n */\nexport function defineSchema<const TSchemaDefinition extends SchemaDefinition>(\n  definition: TSchemaDefinition,\n): TSchemaDefinition {\n  return definition\n}\n\n/**\n * @public\n */\nexport type StyleDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type ListDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type DecoratorDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type AnnotationDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type BlockObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type InlineObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n","import type {Schema} from './schema'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  [key: string]: unknown\n  _type: string\n}\n\n/**\n * @public\n */\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type PortableTextBlock = PortableTextTextBlock | PortableTextObject\n\n/**\n * @public\n */\nexport interface PortableTextTextBlock<\n  TChild = PortableTextSpan | PortableTextObject,\n> {\n  _type: string\n  _key: string\n  children: TChild[]\n  markDefs?: PortableTextObject[]\n  listItem?: string\n  style?: string\n  level?: number\n}\n\n/**\n * @public\n */\nexport function isTextBlock(\n  context: {schema: Schema},\n  block: unknown,\n): block is PortableTextTextBlock {\n  if (!isTypedObject(block)) {\n    return false\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return false\n  }\n\n  if (!Array.isArray(block.children)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextSpan {\n  _key: string\n  _type: 'span'\n  text: string\n  marks?: string[]\n}\n\n/**\n * @public\n */\nexport function isSpan(\n  context: {schema: Schema},\n  child: unknown,\n): child is PortableTextSpan {\n  if (!isTypedObject(child)) {\n    return false\n  }\n\n  if (child._type !== context.schema.span.name) {\n    return false\n  }\n\n  if (typeof child.text !== 'string') {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextObject {\n  _type: string\n  _key: string\n  [other: string]: unknown\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/sanity-bridge/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/sanity-bridge/src/portable-text-member-schema-types.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/sanity-bridge/src/portable-text-member-schema-types-to-schema.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/sanity-bridge/src/sanity-schema-to-portable-text-schema.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/sanity-bridge/src/key-generator.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/sanity-bridge/src/schema-definition-to-portable-text-member-schema-types.ts"],"sourcesContent":["import type {\n  ArraySchemaType,\n  BlockDecoratorDefinition,\n  BlockListDefinition,\n  BlockSchemaType,\n  BlockStyleDefinition,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\n\n/**\n * @public\n * Sanity-specific schema types for Portable Text.\n */\nexport type PortableTextMemberSchemaTypes = {\n  annotations: (ObjectSchemaType & {i18nTitleKey?: string})[]\n  block: ObjectSchemaType\n  blockObjects: ObjectSchemaType[]\n  decorators: BlockDecoratorDefinition[]\n  inlineObjects: ObjectSchemaType[]\n  portableText: ArraySchemaType<PortableTextBlock>\n  span: ObjectSchemaType\n  styles: BlockStyleDefinition[]\n  lists: BlockListDefinition[]\n}\n\n/**\n * @public\n * Create Sanity-specific schema types for Portable Text from a Sanity array\n * schema type.\n */\nexport function createPortableTextMemberSchemaTypes(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): PortableTextMemberSchemaTypes {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portabletextType' missing (required)\")\n  }\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: (spanType as SpanSchemaType).annotations,\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {PortableTextMemberSchemaTypes} from './portable-text-member-schema-types'\n\n/**\n * @public\n * Convert Sanity-specific schema types for Portable Text to a first-class\n * Portable Text schema.\n */\nexport function portableTextMemberSchemaTypesToSchema(\n  schema: PortableTextMemberSchemaTypes,\n): Schema {\n  return {\n    annotations: schema.annotations.map((annotation) => ({\n      name: annotation.name,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: annotation.title,\n    })),\n    block: {\n      name: schema.block.name,\n    },\n    blockObjects: schema.blockObjects.map((blockObject) => ({\n      name: blockObject.name,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: blockObject.title,\n    })),\n    decorators: schema.decorators.map((decorator) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value,\n    })),\n    inlineObjects: schema.inlineObjects.map((inlineObject) => ({\n      name: inlineObject.name,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: inlineObject.title,\n    })),\n    span: {\n      name: schema.span.name,\n    },\n    styles: schema.styles.map((style) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value,\n    })),\n    lists: schema.lists.map((list) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value,\n    })),\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {builtinTypes} from '@sanity/schema/_internal'\nimport type {ArrayDefinition, ArraySchemaType} from '@sanity/types'\nimport {createPortableTextMemberSchemaTypes} from './portable-text-member-schema-types'\nimport {portableTextMemberSchemaTypesToSchema} from './portable-text-member-schema-types-to-schema'\n\n/**\n * @public\n * Compile a Sanity schema to a Portable Text `Schema`.\n *\n * A Portable Text `Schema` is compatible with a Portable Text\n * `SchemaDefinition` and can be used as configuration for the Portable Text\n * Editor.\n *\n * @example\n * ```tsx\n * const schema = sanitySchemaToPortableTextSchema(sanitySchema)\n *\n * return (\n *   <EditorProvider\n *     initialConfig={{\n *       // ...\n *       schemaDefinition: schema,\n *     }}\n *   >\n *     // ...\n *   </EditorProvider>\n * ```\n */\nexport function sanitySchemaToPortableTextSchema(\n  sanitySchema: ArraySchemaType<unknown> | ArrayDefinition,\n): Schema {\n  const portableTextMemberSchemaTypes = createPortableTextMemberSchemaTypes(\n    sanitySchema.hasOwnProperty('jsonType')\n      ? sanitySchema\n      : compileType(sanitySchema),\n  )\n\n  return portableTextMemberSchemaTypesToSchema(portableTextMemberSchemaTypes)\n}\n\nfunction compileType(rawType: any) {\n  return SanitySchema.compile({\n    name: 'blockTypeSchema',\n    types: [rawType, ...builtinTypes],\n  }).get(rawType.name)\n}\n","export const keyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SchemaDefinition} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {\n  defineField,\n  defineType,\n  isArraySchemaType,\n  isObjectSchemaType,\n  type ObjectSchemaType,\n} from '@sanity/types'\nimport startCase from 'lodash.startcase'\nimport {keyGenerator} from './key-generator'\nimport {\n  createPortableTextMemberSchemaTypes,\n  type PortableTextMemberSchemaTypes,\n} from './portable-text-member-schema-types'\n\nconst temporaryImageBlockObjectName = `tmp-${keyGenerator()}-image`\nconst temporaryUrlBlockObjectName = `tmp-${keyGenerator()}-url`\nconst temporaryImageInlineObjectName = `tmp-${keyGenerator()}-image`\nconst temporaryUrlInlineObjectName = `tmp-${keyGenerator()}-url`\n\nconst temporaryBlockObjectNames: Record<string, string> = {\n  image: temporaryImageBlockObjectName,\n  url: temporaryUrlBlockObjectName,\n}\n\nconst temporaryInlineObjectNames: Record<string, string> = {\n  image: temporaryImageInlineObjectName,\n  url: temporaryUrlInlineObjectName,\n}\n\nconst blockObjectNames: Record<string, string> = {\n  [temporaryImageBlockObjectName]: 'image',\n  [temporaryUrlBlockObjectName]: 'url',\n}\n\nconst inlineObjectNames: Record<string, string> = {\n  [temporaryImageInlineObjectName]: 'image',\n  [temporaryUrlInlineObjectName]: 'url',\n}\n\nconst defaultObjectTitles: Record<string, string> = {\n  image: 'Image',\n  url: 'URL',\n}\n\n/**\n * @public\n * Compile a Portable Text schema definition to Sanity-specific schema types for\n * Portable Text.\n */\nexport function compileSchemaDefinitionToPortableTextMemberSchemaTypes(\n  definition?: SchemaDefinition,\n): PortableTextMemberSchemaTypes {\n  const blockObjects =\n    definition?.blockObjects?.map((blockObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with certain names.\n        name: temporaryBlockObjectNames[blockObject.name] ?? blockObject.name,\n        title:\n          blockObject.title === undefined\n            ? // This avoids the default title which is a title case of the object name\n              defaultObjectTitles[blockObject.name]\n            : blockObject.title,\n        fields:\n          blockObject.fields?.map((field) => ({\n            name: field.name,\n            type: field.type,\n            title: field.title ?? startCase(field.name),\n          })) ?? [],\n      }),\n    ) ?? []\n\n  const inlineObjects =\n    definition?.inlineObjects?.map((inlineObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with certain names.\n        name:\n          temporaryInlineObjectNames[inlineObject.name] ?? inlineObject.name,\n\n        title:\n          inlineObject.title === undefined\n            ? // This avoids the default title which is a title case of the object name\n              defaultObjectTitles[inlineObject.name]\n            : inlineObject.title,\n        fields:\n          inlineObject.fields?.map((field) => ({\n            name: field.name,\n            type: field.type,\n            title: field.title ?? startCase(field.name),\n          })) ?? [],\n      }),\n    ) ?? []\n\n  const portableTextSchema = defineField({\n    type: 'array',\n    name: 'portable-text',\n    of: [\n      ...blockObjects.map((blockObject) => ({type: blockObject.name})),\n      {\n        type: 'block',\n        name: 'block',\n        of: inlineObjects.map((inlineObject) => ({type: inlineObject.name})),\n        marks: {\n          decorators:\n            definition?.decorators?.map((decorator) => ({\n              title: decorator.title ?? startCase(decorator.name),\n              value: decorator.name,\n            })) ?? [],\n          annotations:\n            definition?.annotations?.map((annotation) => ({\n              name: annotation.name,\n              type: 'object',\n              title: annotation.title,\n              fields:\n                annotation.fields?.map((field) => ({\n                  name: field.name,\n                  title: field.title ?? startCase(field.name),\n                  type: field.type,\n                })) ?? [],\n            })) ?? [],\n        },\n        lists:\n          definition?.lists?.map((list) => ({\n            value: list.name,\n            title: list.title ?? startCase(list.name),\n          })) ?? [],\n        styles:\n          definition?.styles?.map((style) => ({\n            value: style.name,\n            title: style.title ?? startCase(style.name),\n          })) ?? [],\n      },\n    ],\n  })\n\n  const schema = SanitySchema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects],\n  }).get('portable-text')\n\n  const pteSchema = createPortableTextMemberSchemaTypes(schema)\n\n  return {\n    ...pteSchema,\n    portableText: {\n      ...pteSchema.portableText,\n      of: pteSchema.portableText.of.map((schemaType) => {\n        if (!isObjectSchemaType(schemaType)) {\n          return schemaType\n        }\n\n        const nameMapping = blockObjectNames[schemaType.name]\n\n        schemaType.name = nameMapping ?? schemaType.name\n\n        for (const field of schemaType.fields) {\n          if (field.name !== 'children' || !isArraySchemaType(field.type)) {\n            continue\n          }\n\n          for (const ofSchemaType of field.type.of) {\n            const nameMapping = inlineObjectNames[ofSchemaType.name]\n\n            if (!nameMapping) {\n              continue\n            }\n\n            ofSchemaType.name = nameMapping\n          }\n        }\n\n        return schemaType\n      }),\n    },\n    blockObjects: pteSchema.blockObjects.map((blockObject) =>\n      blockObjectNames[blockObject.name] !== undefined\n        ? ({\n            ...blockObject,\n            name: blockObjectNames[blockObject.name],\n            type: {\n              ...blockObject.type,\n              name: blockObjectNames[blockObject.name],\n            },\n          } as ObjectSchemaType)\n        : blockObject,\n    ),\n    inlineObjects: pteSchema.inlineObjects.map((inlineObject) =>\n      inlineObjectNames[inlineObject.name] !== undefined\n        ? ({\n            ...inlineObject,\n            name: inlineObjectNames[inlineObject.name],\n          } as ObjectSchemaType)\n        : inlineObject,\n    ),\n  } satisfies PortableTextMemberSchemaTypes\n}\n"],"names":["SanitySchema","nameMapping"],"mappings":"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"}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/util/resolveJsType.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/types.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/flatten-nested-blocks.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/constants.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/helpers.ts"],"sourcesContent":["const objectToString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (objectToString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","import type {PortableTextObject} from '@portabletext/schema'\nimport type {SchemaMatchers} from './schema-matchers'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  _type: string\n  _key?: string\n}\n\n/**\n * @public\n */\nexport interface ArbitraryTypedObject extends TypedObject {\n  [key: string]: unknown\n}\n\nexport function isArbitraryTypedObject(\n  object: unknown,\n): object is ArbitraryTypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\nexport interface MinimalSpan {\n  _type: 'span'\n  _key?: string\n  text: string\n  marks?: string[]\n}\n\nexport interface MinimalBlock extends TypedObject {\n  _type: 'block'\n  children: TypedObject[]\n  markDefs?: TypedObject[]\n  style?: string\n  level?: number\n  listItem?: string\n}\n\nexport interface PlaceholderDecorator {\n  _type: '__decorator'\n  name: string\n  children: TypedObject[]\n}\n\nexport interface PlaceholderAnnotation {\n  _type: '__annotation'\n  markDef: PortableTextObject\n  children: TypedObject[]\n}\n\n/**\n * @public\n */\nexport type HtmlParser = (html: string) => Document\n\n/**\n * @public\n */\nexport type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize'\n\n/**\n * @public\n */\nexport interface HtmlDeserializerOptions {\n  keyGenerator?: () => string\n  rules?: DeserializerRule[]\n  parseHtml?: HtmlParser\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n  /**\n   * Custom schema matchers to use when deserializing HTML to Portable Text.\n   * @beta\n   */\n  matchers?: SchemaMatchers\n}\n\nexport interface HtmlPreprocessorOptions {\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n}\n\n/**\n * @public\n */\nexport interface DeserializerRule {\n  deserialize: (\n    el: Node,\n    next: (\n      elements: Node | Node[] | NodeList,\n    ) => TypedObject | TypedObject[] | undefined,\n    createBlock: (props: ArbitraryTypedObject) => {\n      _type: string\n      block: ArbitraryTypedObject\n    },\n  ) => TypedObject | TypedObject[] | undefined\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport {\n  isArbitraryTypedObject,\n  type ArbitraryTypedObject,\n  type TypedObject,\n} from '../types'\n\nexport function flattenNestedBlocks(\n  context: {\n    schema: Schema\n  },\n  blocks: Array<ArbitraryTypedObject>,\n): TypedObject[] {\n  const flattened = blocks.flatMap((block) => {\n    if (isBlockContainer(block)) {\n      return flattenNestedBlocks(context, [block.block])\n    }\n\n    if (isTextBlock(context, block)) {\n      const hasBlockObjects = block.children.some((child) => {\n        const knownBlockObject = context.schema.blockObjects.some(\n          (blockObject) => blockObject.name === child._type,\n        )\n        return knownBlockObject\n      })\n      const hasBlocks = block.children.some(\n        (child) => child._type === '__block' || child._type === 'block',\n      )\n\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block)\n\n        if (\n          splitChildren.length === 1 &&\n          splitChildren[0].type === 'children' &&\n          isEqual(splitChildren[0].children, block.children)\n        ) {\n          return [block]\n        }\n\n        return splitChildren.flatMap((slice) => {\n          if (slice.type === 'block object') {\n            return [slice.block]\n          }\n\n          if (slice.type === 'block') {\n            return flattenNestedBlocks(context, [\n              slice.block as ArbitraryTypedObject,\n            ])\n          }\n\n          if (slice.children.length > 0) {\n            if (\n              slice.children.every(\n                (child) => isSpan(context, child) && child.text.trim() === '',\n              )\n            ) {\n              return []\n            }\n\n            return flattenNestedBlocks(context, [\n              {\n                ...block,\n                children: slice.children,\n              },\n            ])\n          }\n\n          return []\n        })\n      }\n\n      return [block]\n    }\n\n    return [block]\n  })\n\n  return flattened\n}\n\nfunction isBlockContainer(\n  block: ArbitraryTypedObject,\n): block is BlockContainer {\n  return block._type === '__block' && isArbitraryTypedObject(block.block)\n}\n\ntype BlockContainer = {\n  _type: '__block'\n  block: ArbitraryTypedObject\n}\n\nfunction getSplitChildren(\n  context: {schema: Schema},\n  block: PortableTextTextBlock,\n) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type,\n      )\n      const knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type,\n      )\n\n      const lastSlice = slices.pop()\n\n      if (!isSpan(context, child) && !knownInlineObject) {\n        if (knownBlockObject) {\n          return [\n            ...slices,\n            ...(lastSlice ? [lastSlice] : []),\n            {type: 'block object' as const, block: child},\n          ]\n        }\n      }\n\n      if (child._type === '__block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {\n            type: 'block object' as const,\n            block: (child as any).block,\n          },\n        ]\n      }\n\n      if (child._type === 'block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {type: 'block' as const, block: child},\n        ]\n      }\n\n      if (lastSlice) {\n        if (lastSlice.type === 'children') {\n          return [\n            ...slices,\n            {\n              type: 'children' as const,\n              children: [...lastSlice.children, child],\n            },\n          ]\n        }\n      }\n\n      return [\n        ...slices,\n        ...(lastSlice ? [lastSlice] : []),\n        {type: 'children' as const, children: [child]},\n      ]\n    },\n    [] as Array<\n      | {\n          type: 'children'\n          children: Array<PortableTextSpan | PortableTextObject>\n        }\n      | {type: 'block object'; block: PortableTextObject}\n      | {type: 'block'; block: PortableTextBlock}\n    >,\n  )\n}\n","import {uniq} from 'lodash'\n\nexport interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<\n  string,\n  {object: null} | undefined\n> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = uniq(\n  Object.values(ELEMENT_MAP)\n    .filter((tag): tag is PartialBlock => 'style' in tag)\n    .map((tag) => tag.style),\n)\n\nexport const DEFAULT_SUPPORTED_DECORATORS = uniq(\n  Object.values(HTML_DECORATOR_TAGS),\n)\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","import type {Schema} from '@portabletext/schema'\nimport {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport {DEFAULT_BLOCK} from '../constants'\nimport type {\n  ArbitraryTypedObject,\n  HtmlParser,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {resolveJsType} from '../util/resolveJsType'\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function ensureRootIsBlocks(\n  schema: Schema,\n  objects: Array<ArbitraryTypedObject>,\n): ArbitraryTypedObject[] {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === 'block') {\n      blocks.push(node)\n      return blocks\n    }\n\n    if (node._type === '__block') {\n      blocks.push((node as any).block)\n      return blocks\n    }\n\n    const lastBlock = blocks[blocks.length - 1]\n    if (\n      i > 0 &&\n      !isTextBlock({schema}, original[i - 1]) &&\n      isTextBlock({schema}, lastBlock)\n    ) {\n      lastBlock.children.push(node as PortableTextObject)\n      return blocks\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    blocks.push(block)\n    return blocks\n  }, [] as ArbitraryTypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) === '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(\n  node: TypedObject,\n): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(\n  node: TypedObject,\n): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1196, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/block-tools/lib/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/node_modules/.pnpm/%40vercel%2Bstega%400.1.2/node_modules/%40vercel/stega/dist/index.mjs","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/util/randomKey.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/asserters.word-online.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/preprocessor.word-online.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/xpathResult.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.gdocs.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.html.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.notion.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.whitespace.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.word.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/index.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/rules.word-online.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.gdocs.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.whitespace-text-node.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.html.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.notion.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.word.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/index.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/trim-whitespace.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/index.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/util/normalizeBlock.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/block-tools/src/index.ts"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","export function keyGenerator() {\n  return randomKey(12)\n}\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).slice(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import {isElement, tagName} from '../helpers'\n\nexport function isWordOnlineHtml(html: string): boolean {\n  return (\n    /class=\"(?:TextRun|NormalTextRun)[^\"]*SCXW\\d+[^\"]*BCX\\d+/.test(html) ||\n    /class=\"EOP[^\"]*SCXW\\d+/.test(html)\n  )\n}\n\nexport function isWordOnlineTextRun(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('TextRun') && !el.classList.contains('EOP')\n}\n\n/**\n * Identifies the inner text holder spans in Word Online's nested structure.\n * Word Online uses: <span class=\"TextRun\"><span class=\"NormalTextRun\">text</span></span>\n * This function matches the inner span where actual text content lives.\n * Use this to find the text-bearing children within a TextRun container.\n */\nexport function isNormalTextRun(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('NormalTextRun')\n}\n\n/**\n * Identifies the outer container spans in Word Online's nested structure.\n * Word Online uses: <span class=\"TextRun\"><span class=\"NormalTextRun\">text</span></span>\n * This function matches the outer span that holds formatting and contains NormalTextRun children.\n * Use this to find the top-level containers, then search within for NormalTextRun spans.\n * Note: Excludes spans that also have \"NormalTextRun\" or \"EOP\" classes.\n */\nexport function isTextRunSpan(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return (\n    el.classList.contains('TextRun') &&\n    !el.classList.contains('NormalTextRun') &&\n    !el.classList.contains('EOP')\n  )\n}\n\nexport function isEmptyOutlineElement(el: Element): boolean {\n  if (!isElement(el)) {\n    return false\n  }\n\n  if (!el.classList.contains('OutlineElement')) {\n    return false\n  }\n\n  return el.textContent.trim() === ''\n}\n\nexport function isFindHit(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('FindHit')\n}\n\nexport function isInHeading(el: Node): boolean {\n  let current: Node | null = el\n\n  while (current) {\n    if (isElement(current)) {\n      if (\n        tagName(current) === 'word-online-block' &&\n        /^heading \\d$/.test(current.getAttribute('data-parastyle') ?? '')\n      ) {\n        return true\n      }\n    }\n\n    current = current.parentNode\n  }\n\n  return false\n}\n\nexport function isInBlockquote(el: Node): boolean {\n  let current: Node | null = el\n\n  while (current) {\n    if (isElement(current)) {\n      if (\n        tagName(current) === 'word-online-block' &&\n        current.getAttribute('data-parastyle') === 'Quote'\n      ) {\n        return true\n      }\n    }\n\n    current = current.parentNode\n  }\n\n  return false\n}\n\n/**********************\n * Formatting asserters\n **********************/\n\nexport function hasStrongFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('MacChromeBold') ||\n    /font-weight\\s*:\\s*bold/.test(style)\n  )\n}\n\nexport function hasEmphasisFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return /font-style\\s*:\\s*italic/.test(style)\n}\n\nexport function hasUnderlineFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('Underlined') ||\n    /text-decoration\\s*:\\s*underline/.test(style)\n  )\n}\n\nexport function hasStrikethroughFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('Strikethrough') ||\n    /text-decoration\\s*:\\s*line-through/.test(style)\n  )\n}\n\nexport function hasFormatting(el: Element): boolean {\n  return (\n    hasStrongFormatting(el) ||\n    hasEmphasisFormatting(el) ||\n    hasUnderlineFormatting(el) ||\n    hasStrikethroughFormatting(el)\n  )\n}\n","import {isElement, tagName} from '../helpers'\nimport {\n  hasFormatting,\n  isNormalTextRun,\n  isTextRunSpan,\n  isWordOnlineHtml,\n} from './asserters.word-online'\n\nexport function preprocessWordOnline(html: string, doc: Document): Document {\n  if (!isWordOnlineHtml(html)) {\n    return doc\n  }\n\n  const paragraphs = Array.from(\n    doc.querySelectorAll('p.Paragraph[role=\"heading\"]'),\n  )\n\n  for (const paragraph of paragraphs) {\n    const ariaLevel = paragraph.getAttribute('aria-level')\n\n    if (ariaLevel) {\n      const wrapper = doc.createElement('word-online-block')\n\n      wrapper.setAttribute('data-parastyle', `heading ${ariaLevel}`)\n\n      const parent = paragraph.parentNode\n\n      if (parent) {\n        parent.insertBefore(wrapper, paragraph)\n\n        while (paragraph.firstChild) {\n          wrapper.appendChild(paragraph.firstChild)\n        }\n\n        parent.removeChild(paragraph)\n      }\n    }\n  }\n\n  // Group NormalTextRun spans with the same data-ccp-parastyle attribute\n  // This handles cases like blockquotes, headings where multiple spans should form one block\n  // Process from the body directly to handle DOM mutations\n  let child = doc.body.firstChild\n\n  while (child) {\n    const next = child.nextSibling\n\n    if (!isElement(child) || !tagName(child)?.includes('span')) {\n      child = next\n\n      continue\n    }\n\n    const paraStyle = getParaStyle(child)\n\n    if (!paraStyle) {\n      child = next\n\n      continue\n    }\n\n    // Found a span with paragraph style - collect all consecutive siblings with same style\n    const group: Element[] = [child]\n    let sibling = next\n\n    while (sibling) {\n      if (!isElement(sibling) || getParaStyle(sibling) !== paraStyle) {\n        break\n      }\n\n      group.push(sibling)\n      sibling = sibling.nextSibling\n    }\n\n    // Wrap the spans in a container\n    // Use a custom element name to avoid conflicts with HTML rules\n    const wrapper = doc.createElement('word-online-block')\n    wrapper.setAttribute('data-parastyle', paraStyle)\n\n    // Insert the wrapper before the first span\n    doc.body.insertBefore(wrapper, child)\n\n    // Move all grouped spans into the wrapper\n    for (const span of group) {\n      wrapper.appendChild(span)\n    }\n\n    // Continue with the sibling after the last grouped span\n    child = sibling\n  }\n\n  // Find all TextRun spans\n  const textRunSpans = Array.from(doc.body.querySelectorAll('span')).filter(\n    isTextRunSpan,\n  )\n\n  for (const textRunSpan of textRunSpans) {\n    // Find ALL NormalTextRun children (Word Online can have multiple per TextRun)\n    const normalTextRuns = Array.from(textRunSpan.childNodes).filter(\n      isNormalTextRun,\n    )\n\n    for (const normalTextRun of normalTextRuns) {\n      // Process ALL nested spans with whitespace in this NormalTextRun\n      // We need to process them in a loop since removing one might affect indices\n      let foundNestedSpan = true\n\n      while (foundNestedSpan) {\n        const children = Array.from(normalTextRun.childNodes)\n        const nestedSpanIndex = children.findIndex(\n          (node) =>\n            isElement(node) &&\n            tagName(node) === 'span' &&\n            node.textContent.trim() === '',\n        )\n\n        if (nestedSpanIndex === -1) {\n          foundNestedSpan = false\n          break\n        }\n\n        const nestedSpan = children.at(nestedSpanIndex)\n\n        if (!nestedSpan) {\n          foundNestedSpan = false\n          break\n        }\n\n        // Word Online uses non-breaking spaces, convert to regular spaces\n        const spaceText = nestedSpan.textContent?.replace(/\\u00a0/g, ' ') ?? ''\n\n        // Determine if the space is at the beginning or end BEFORE removing it\n        // Check if there are any text nodes before this position\n        const hasTextBefore = children\n          .slice(0, nestedSpanIndex)\n          .some((n) => n.nodeType === 3)\n        const isSpaceAtBeginning = !hasTextBefore\n\n        // Remove the nested span\n        normalTextRun.removeChild(nestedSpan)\n\n        if (isSpaceAtBeginning) {\n          // Space at the beginning - keep it at the beginning\n          const firstTextNode = Array.from(normalTextRun.childNodes).find(\n            (n) => n.nodeType === 3,\n          )\n\n          if (firstTextNode) {\n            firstTextNode.textContent =\n              spaceText + (firstTextNode.textContent || '')\n          } else {\n            // No text node exists, create one with the space\n            const spaceNode = doc.createTextNode(spaceText)\n            normalTextRun.insertBefore(spaceNode, normalTextRun.firstChild)\n          }\n        } else {\n          // Space at the end - check if we should move it to the next TextRun\n          // Only move if the formatting (marks) are different\n          const nextSibling = textRunSpan.nextSibling\n          const currentHasFormatting = hasFormatting(textRunSpan)\n\n          if (\n            nextSibling &&\n            isElement(nextSibling) &&\n            isTextRunSpan(nextSibling)\n          ) {\n            const nextHasFormatting = hasFormatting(nextSibling)\n\n            // If current has formatting but next doesn't, move space to the next span\n            // This makes semantic sense: \"**bar** baz\" or \"*bar* baz\"  space should be outside the formatting\n            if (currentHasFormatting && !nextHasFormatting) {\n              const nextNormalTextRun = Array.from(nextSibling.childNodes).find(\n                isNormalTextRun,\n              )\n\n              if (nextNormalTextRun && isElement(nextNormalTextRun)) {\n                // Prepend space to the first text node of the next NormalTextRun\n                const firstChild = nextNormalTextRun.firstChild\n\n                if (firstChild && firstChild.nodeType === 3) {\n                  firstChild.textContent =\n                    spaceText + (firstChild.textContent ?? '')\n                } else {\n                  // No text node, insert a new one at the beginning\n                  const spaceNode = doc.createTextNode(spaceText)\n                  nextNormalTextRun.insertBefore(\n                    spaceNode,\n                    nextNormalTextRun.firstChild,\n                  )\n                }\n              }\n              // Don't add the space back to the current span - it's been moved\n            } else {\n              // Same formatting, keep the space in the current span\n              const lastTextNode = Array.from(normalTextRun.childNodes).find(\n                (n) => n.nodeType === 3,\n              )\n\n              if (lastTextNode) {\n                lastTextNode.textContent =\n                  (lastTextNode.textContent ?? '') + spaceText\n              } else {\n                // No text node exists, create one with the space\n                const spaceNode = doc.createTextNode(spaceText)\n                normalTextRun.appendChild(spaceNode)\n              }\n            }\n          } else {\n            // No next TextRun, keep the space at the end of this span's text\n            const lastTextNode = Array.from(normalTextRun.childNodes).find(\n              (n) => n.nodeType === 3,\n            )\n\n            if (lastTextNode) {\n              lastTextNode.textContent =\n                (lastTextNode.textContent ?? '') + spaceText\n            } else {\n              // No text node exists, create one with the space\n              const spaceNode = doc.createTextNode(spaceText)\n              normalTextRun.appendChild(spaceNode)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return doc\n}\n\n// Helper to get paragraph style from a span (either directly or from NormalTextRun child)\nfunction getParaStyle(element: Element): string | undefined {\n  // Check direct attribute first\n  const directStyle = element.getAttribute('data-ccp-parastyle')\n\n  if (directStyle) {\n    return directStyle\n  }\n\n  // Check if it's a TextRun with NormalTextRun children that have the attribute\n  if (tagName(element) === 'span' && element.classList.contains('TextRun')) {\n    const normalTextRuns = Array.from(\n      element.querySelectorAll('.NormalTextRun'),\n    )\n\n    if (normalTextRuns.length > 0) {\n      const firstStyle = normalTextRuns[0].getAttribute('data-ccp-parastyle')\n\n      // Verify all NormalTextRuns have the same style\n      if (\n        firstStyle &&\n        normalTextRuns.every(\n          (normalTextRun) =>\n            normalTextRun.getAttribute('data-ccp-parastyle') === firstStyle,\n        )\n      ) {\n        return firstStyle\n      }\n    }\n  }\n\n  return undefined\n}\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import {tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport function preprocessGDocs(_html: string, doc: Document): Document {\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (\n        tagName(elm) === 'li' &&\n        elm.firstChild &&\n        tagName(elm?.firstChild) === 'img'\n      ) {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(\n        ...Array.from(gDocsRootOrSiblingNode.childNodes),\n      )\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport function preprocessHTML(_html: string, doc: Document): Document {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport function preprocessNotion(html: string, doc: Document): Document {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\n// Elements that only contain block-level children (not inline text content)\nconst BLOCK_CONTAINER_ELEMENTS = [\n  'body',\n  'table',\n  'tbody',\n  'thead',\n  'tfoot',\n  'tr',\n  'ul',\n  'ol',\n]\n\nexport function preprocessWhitespace(_: string, doc: Document): Document {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(\n        node.parentElement?.tagName.toLowerCase() || '',\n      )\n    ) {\n      const normalized =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n      const parentTag = node.parentElement?.tagName.toLowerCase()\n\n      if (\n        parentTag &&\n        BLOCK_CONTAINER_ELEMENTS.includes(parentTag) &&\n        normalized.trim() === ''\n      ) {\n        // If parent is a block container and text is only whitespace, remove it\n        node.parentNode?.removeChild(node)\n      } else {\n        node.textContent = normalized\n      }\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      // Process children in reverse to handle removals safely\n      for (let i = node.childNodes.length - 1; i >= 0; i--) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX =\n  /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport function preprocessWord(html: string, doc: Document): Document {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = doc.createTextNode(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = doc.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import {preprocessWordOnline} from '../word-online/preprocessor.word-online'\nimport {preprocessGDocs} from './preprocessor.gdocs'\nimport {preprocessHTML} from './preprocessor.html'\nimport {preprocessNotion} from './preprocessor.notion'\nimport {preprocessWhitespace} from './preprocessor.whitespace'\nimport {preprocessWord} from './preprocessor.word'\n\nexport const preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessWordOnline,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import type {Schema} from '@portabletext/schema'\nimport {DEFAULT_SPAN, HTML_BLOCK_TAGS, HTML_HEADER_TAGS} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {\n  hasEmphasisFormatting,\n  hasStrikethroughFormatting,\n  hasStrongFormatting,\n  hasUnderlineFormatting,\n  isFindHit,\n  isInBlockquote,\n  isInHeading,\n  isNormalTextRun,\n  isWordOnlineTextRun,\n} from './asserters.word-online'\n\nfunction mapParaStyleToBlockStyle(schema: Schema, paraStyle: string) {\n  const blockStyleMap: Record<string, string> = {\n    'heading 1': 'h1',\n    'heading 2': 'h2',\n    'heading 3': 'h3',\n    'heading 4': 'h4',\n    'heading 5': 'h5',\n    'heading 6': 'h6',\n    'Quote': 'blockquote',\n  }\n\n  const blockStyle = blockStyleMap[paraStyle] ?? 'normal'\n\n  return schema.styles.find((style) => style.name === blockStyle)?.name\n}\n\nexport function createWordOnlineRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    // Image rule - handles bare Word Online <img> tags with WACImage class\n    {\n      deserialize(el) {\n        if (!isElement(el) || tagName(el) !== 'img') {\n          return undefined\n        }\n\n        // Handle className which might be a string or SVGAnimatedString\n        const classNameRaw = el.className\n        let className = ''\n        if (typeof classNameRaw === 'string') {\n          className = classNameRaw\n        } else if (classNameRaw && typeof classNameRaw === 'object') {\n          // SVGAnimatedString has baseVal property\n          className = (classNameRaw as {baseVal?: string}).baseVal || ''\n        }\n\n        if (!className.includes('WACImage')) {\n          return undefined\n        }\n\n        const src = el.getAttribute('src') ?? undefined\n        const alt = el.getAttribute('alt') ?? undefined\n\n        const props = Object.fromEntries(\n          Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n        )\n\n        // Bare <img> tags are typically block-level, not inline\n        // They should be returned as block images\n        const image = options.matchers?.image?.({\n          context: {\n            schema: schema,\n            keyGenerator: options.keyGenerator ?? keyGenerator,\n          },\n          props: {\n            ...props,\n            ...(src ? {src} : {}),\n            ...(alt ? {alt} : {}),\n          },\n        })\n\n        if (image) {\n          return {\n            _type: '__block',\n            block: image,\n          }\n        }\n\n        return undefined\n      },\n    },\n    // Image rule - handles Word Online images wrapped in WACImageContainer\n    {\n      deserialize(el) {\n        if (!isElement(el)) {\n          return undefined\n        }\n\n        // Handle className which might be a string or SVGAnimatedString\n        const classNameRaw = el.className\n        let className = ''\n        if (typeof classNameRaw === 'string') {\n          className = classNameRaw\n        } else if (classNameRaw && typeof classNameRaw === 'object') {\n          // SVGAnimatedString has baseVal property\n          className = (classNameRaw as {baseVal?: string}).baseVal || ''\n        }\n        if (!className.includes('WACImageContainer')) {\n          return undefined\n        }\n\n        // Find the img element inside\n        const img = el.querySelector('img')\n        if (!img) {\n          return undefined\n        }\n\n        const src = img.getAttribute('src') ?? undefined\n        const alt = img.getAttribute('alt') ?? undefined\n\n        const props = Object.fromEntries(\n          Array.from(img.attributes).map((attr) => [attr.name, attr.value]),\n        )\n\n        // Determine if this should be an inline or block-level image\n        // Word Online inline images:\n        // 1. Siblings of TextRun spans (not wrapped in paragraphs)\n        // 2. Inside list items (should be inline relative to the list item)\n        const isInsideListItem = el.closest('li') !== null\n        const isInsideParagraph = el.closest('p') !== null\n\n        if (!isInsideParagraph || isInsideListItem) {\n          // Inline image (either not in a paragraph, or inside a list item)\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema: schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n        }\n\n        // Block-level image (or fallback if inline image not supported)\n        const image = options.matchers?.image?.({\n          context: {\n            schema: schema,\n            keyGenerator: options.keyGenerator ?? keyGenerator,\n          },\n          props: {\n            ...props,\n            ...(src ? {src} : {}),\n            ...(alt ? {alt} : {}),\n          },\n        })\n\n        if (image) {\n          return {\n            _type: '__block',\n            block: image,\n          }\n        }\n\n        return undefined\n      },\n    },\n    // List item rule - handles <li> elements with aria-level\n    {\n      deserialize(el, next) {\n        if (!isElement(el) || tagName(el) !== 'li') {\n          return undefined\n        }\n\n        const ariaLevel = el.getAttribute('data-aria-level')\n\n        if (!ariaLevel) {\n          return undefined\n        }\n\n        const listItem = tagName(el.parentNode) === 'ol' ? 'number' : 'bullet'\n\n        let childNodesToProcess = el.childNodes\n        let blockStyle = 'normal'\n\n        if (\n          el.childNodes.length === 1 &&\n          el.firstChild &&\n          isElement(el.firstChild)\n        ) {\n          const childTag = tagName(el.firstChild)\n\n          if (\n            childTag &&\n            (HTML_BLOCK_TAGS[childTag as keyof typeof HTML_BLOCK_TAGS] ||\n              HTML_HEADER_TAGS[childTag as keyof typeof HTML_HEADER_TAGS] ||\n              childTag === 'word-online-block')\n          ) {\n            // If it's a word-online-block, extract the style before skipping it\n            if (childTag === 'word-online-block') {\n              const paraStyle = el.firstChild.getAttribute('data-parastyle')\n              const foundBlockStyle = paraStyle\n                ? mapParaStyleToBlockStyle(schema, paraStyle)\n                : undefined\n\n              if (foundBlockStyle) {\n                blockStyle = foundBlockStyle\n              }\n            }\n\n            // Skip the block wrapper and process its children directly\n            childNodesToProcess = el.firstChild.childNodes\n          }\n        }\n\n        const children = next(childNodesToProcess)\n        let childArray = Array.isArray(children)\n          ? children\n          : [children].filter(Boolean)\n\n        // Clean up trailing empty or whitespace-only spans\n        // Word Online often adds trailing tabs/breaks and extra spaces in list items\n        while (childArray.length > 0) {\n          const lastChild = childArray[childArray.length - 1]\n\n          if (\n            lastChild &&\n            typeof lastChild === 'object' &&\n            'text' in lastChild\n          ) {\n            const text = (lastChild.text as string).trimEnd()\n            if (text === '') {\n              // Remove empty span\n              childArray = childArray.slice(0, -1)\n            } else if (text !== lastChild.text) {\n              // Update with trimmed text\n              lastChild.text = text\n              break\n            } else {\n              break\n            }\n          } else {\n            break\n          }\n        }\n\n        return {\n          _type: schema.block.name,\n          children: childArray,\n          markDefs: [],\n          style: blockStyle,\n          listItem,\n          level: parseInt(ariaLevel, 10),\n        }\n      },\n    },\n    // Block style rule - handles paragraph styles like Quote\n    // The preprocessor wraps grouped NormalTextRun spans in a word-online-block element\n    {\n      deserialize(el, next) {\n        if (!isElement(el)) {\n          return undefined\n        }\n\n        const paraStyle = el.getAttribute('data-parastyle')\n        const blockStyle = paraStyle\n          ? mapParaStyleToBlockStyle(schema, paraStyle)\n          : undefined\n\n        if (!blockStyle) {\n          return undefined\n        }\n\n        const children = next(el.childNodes)\n\n        return {\n          _type: schema.block.name,\n          style: blockStyle,\n          markDefs: [],\n          children: Array.isArray(children)\n            ? children\n            : children\n              ? [children]\n              : [],\n        }\n      },\n    },\n    // TextRun rule\n    {\n      deserialize(el) {\n        if (isWordOnlineTextRun(el)) {\n          if (!isElement(el)) {\n            return undefined\n          }\n\n          if (!el.textContent) {\n            return undefined\n          }\n\n          // Find ALL NormalTextRun and FindHit children and extract text from them\n          // (Word Online sometimes splits text across multiple spans)\n          // FindHit is used for search result highlighting\n          const textSpans = Array.from(el.childNodes).filter(\n            (node) => isNormalTextRun(node) || isFindHit(node),\n          )\n          const text = textSpans\n            .map((span) => (isElement(span) ? (span.textContent ?? '') : ''))\n            .join('')\n\n          if (!text) {\n            return undefined\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as Array<string>,\n            text,\n          }\n\n          if (hasStrongFormatting(el)) {\n            span.marks.push('strong')\n          }\n\n          // Don't add italic mark if we're in a heading or blockquote (it's part of their default style)\n          if (\n            hasEmphasisFormatting(el) &&\n            !isInHeading(el) &&\n            !isInBlockquote(el)\n          ) {\n            span.marks.push('em')\n          }\n\n          // Add underline mark if the element has explicit underline formatting\n          // Word Online always adds underline to links, so we need to distinguish between:\n          // 1. Default link underline (skip)\n          // 2. Explicit user underline that includes the link (add)\n          // We check: if the link is surrounded by underlined content, it's explicit user underline\n          if (hasUnderlineFormatting(el)) {\n            const isInsideLink =\n              isElement(el) &&\n              el.parentElement &&\n              tagName(el.parentElement) === 'a'\n\n            if (isInsideLink) {\n              // Check if there are underlined siblings of the link\n              const linkElement = el.parentElement\n              if (linkElement) {\n                const prevSibling = linkElement.previousSibling\n                const nextSibling = linkElement.nextSibling\n\n                // If either sibling is an underlined TextRun, the link is part of explicit underline\n                const hasPrevUnderline =\n                  prevSibling &&\n                  isElement(prevSibling) &&\n                  hasUnderlineFormatting(prevSibling)\n                const hasNextUnderline =\n                  nextSibling &&\n                  isElement(nextSibling) &&\n                  hasUnderlineFormatting(nextSibling)\n\n                if (hasPrevUnderline || hasNextUnderline) {\n                  span.marks.push('underline')\n                }\n                // Otherwise, it's just default link styling, don't add underline mark\n              }\n            } else {\n              // Not in a link, always add underline\n              span.marks.push('underline')\n            }\n          }\n\n          // Add strikethrough mark if the element has strikethrough formatting\n          if (hasStrikethroughFormatting(el)) {\n            span.marks.push('strike-through')\n          }\n\n          return span\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\n// allows for line-through regex to be more lineient to allow for other text-decoration before or after\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(schema: Schema, el: Node): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!schema.styles.some((style) => style.name === block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport function createGDocsRules(schema: Schema): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          if (!el.textContent) {\n            if (!el.previousSibling && !el.nextSibling) {\n              el.setAttribute('data-lonely-child', 'true')\n            }\n\n            return next(el.childNodes)\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(schema, el),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          isRootNode(el)\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {tagName} from '../helpers'\n\nexport const whitespaceTextNodeRule: DeserializerRule = {\n  deserialize(node) {\n    return node.nodeName === '#text' && isWhitespaceTextNode(node)\n      ? {\n          ...DEFAULT_SPAN,\n          marks: [],\n          text: (node.textContent ?? '').replace(/\\s\\s+/g, ' '),\n        }\n      : undefined\n  },\n}\n\nfunction isWhitespaceTextNode(node: Node) {\n  const isValidWhiteSpace =\n    node.nodeType === 3 &&\n    (node.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') ===\n      ' ' &&\n    node.nextSibling &&\n    node.nextSibling.nodeType !== 3 &&\n    node.previousSibling &&\n    node.previousSibling.nodeType !== 3\n\n  return (\n    (isValidWhiteSpace || node.textContent !== ' ') &&\n    tagName(node.parentNode) !== 'body'\n  )\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {whitespaceTextNodeRule} from './rules.whitespace-text-node'\n\nfunction resolveListItem(\n  schema: Schema,\n  listNodeTagName: string,\n): string | undefined {\n  if (\n    listNodeTagName === 'ul' &&\n    schema.lists.some((list) => list.name === 'bullet')\n  ) {\n    return 'bullet'\n  }\n  if (\n    listNodeTagName === 'ol' &&\n    schema.lists.some((list) => list.name === 'number')\n  ) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport function createHTMLRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = schema.styles.some(\n          (style) => style.name === 'code',\n        )\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n        const nonBlockquoteBlocks = Object.keys(blocks)\n\n        const children: HTMLElement[] = []\n\n        el.childNodes.forEach((node, index) => {\n          if (!el.ownerDocument) {\n            return\n          }\n\n          if (\n            node.nodeType === 1 &&\n            nonBlockquoteBlocks.includes(\n              (node as Element).localName.toLowerCase(),\n            )\n          ) {\n            const span = el.ownerDocument.createElement('span')\n\n            const previousChild = children[children.length - 1]\n\n            if (\n              previousChild &&\n              previousChild.nodeType === 3 &&\n              previousChild.textContent?.trim()\n            ) {\n              // Only prepend line break if the previous node is a non-empty\n              // text node.\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n\n            if (index !== el.childNodes.length) {\n              // Only append line break if this is not the last child\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        const blockStyle = block.style\n        // If style is not supported, return a defaultBlockType\n        if (!schema.styles.some((style) => style.name === blockStyle)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (\n          !listItem ||\n          !el.parentNode ||\n          !HTML_LIST_CONTAINER_TAGS[parentTag]\n        ) {\n          return undefined\n        }\n        const enabledListItem = resolveListItem(schema, parentTag)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (\n          !decorator ||\n          !schema.decorators.some(\n            (decoratorType) => decoratorType.name === decorator,\n          )\n        ) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'a') {\n          return undefined\n        }\n        const linkEnabled = schema.annotations.some(\n          (annotation) => annotation.name === 'link',\n        )\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        if (linkEnabled) {\n          return {\n            _type: '__annotation',\n            markDef: {\n              _key: options.keyGenerator\n                ? options.keyGenerator()\n                : keyGenerator(),\n              _type: 'link',\n              href: href,\n            },\n            children: next(el.childNodes),\n          }\n        }\n        return (\n          el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) &&\n          next(el.childNodes)\n        )\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (isElement(el) && (tagName(el) === 'td' || tagName(el) === 'th')) {\n          return {\n            ...DEFAULT_BLOCK,\n            children: next(el.childNodes),\n          }\n        }\n\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'img') {\n          const src = el.getAttribute('src') ?? undefined\n          const alt = el.getAttribute('alt') ?? undefined\n\n          const props = Object.fromEntries(\n            Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n          )\n\n          const ancestorOfLonelyChild =\n            el?.parentElement?.parentElement?.getAttribute('data-lonely-child')\n          const ancestorOfListItem = el.closest('li') !== null\n\n          if (ancestorOfLonelyChild && !ancestorOfListItem) {\n            const image = options.matchers?.image?.({\n              context: {\n                schema,\n                keyGenerator: options.keyGenerator ?? keyGenerator,\n              },\n              props: {\n                ...props,\n                ...(src ? {src} : {}),\n                ...(alt ? {alt} : {}),\n              },\n            })\n\n            if (image) {\n              return {\n                _type: '__block',\n                block: image,\n              }\n            }\n          }\n\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n\n          const image = options.matchers?.image?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (image) {\n            return {\n              _type: '__block',\n              block: image,\n            }\n          }\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return (\n    /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n  )\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nexport function createNotionRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  HTML_HEADER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'number' : 'bullet'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? Number.parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  if (!isElement(el)) {\n    return false\n  }\n\n  // Check for specific class names\n  if (el.className) {\n    if (\n      el.className === 'MsoListParagraphCxSpFirst' ||\n      el.className === 'MsoListParagraphCxSpMiddle' ||\n      el.className === 'MsoListParagraphCxSpLast'\n    ) {\n      return true\n    }\n  }\n\n  // Check for mso-list in style attribute\n  const style = el.getAttribute('style')\n  if (style && /mso-list:\\s*l\\d+\\s+level\\d+\\s+lfo\\d+/.test(style)) {\n    return true\n  }\n\n  return false\n}\n\nfunction getHeadingStyle(el: Node): string | undefined {\n  const tag = tagName(el)\n  if (tag && HTML_HEADER_TAGS[tag]) {\n    return HTML_HEADER_TAGS[tag]?.style\n  }\n  return undefined\n}\n\nexport function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n\n        // Handle list items (both paragraphs and headings)\n        if (\n          (tag === 'p' || HTML_HEADER_TAGS[tag || '']) &&\n          isWordListElement(el)\n        ) {\n          const headingStyle = getHeadingStyle(el)\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: headingStyle || BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {createWordOnlineRules} from '../word-online/rules.word-online'\nimport {createGDocsRules} from './rules.gdocs'\nimport {createHTMLRules} from './rules.html'\nimport {createNotionRules} from './rules.notion'\nimport {createWordRules} from './rules.word'\n\nexport function createRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createWordOnlineRules(schema, options),\n    ...createNotionRules(),\n    ...createGDocsRules(schema),\n    ...createHTMLRules(schema, options),\n  ]\n}\n","import {\n  isSpan,\n  isTextBlock,\n  type PortableTextTextBlock,\n  type Schema,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport type {TypedObject, WhiteSpacePasteMode} from '../types'\nimport {isMinimalSpan} from './helpers'\n\nexport function trimWhitespace(\n  context: {schema: Schema},\n  mode: WhiteSpacePasteMode,\n  blocks: TypedObject[],\n): TypedObject[] {\n  const trimmedBlocks: TypedObject[] = []\n  let consecutiveEmptyCount = 0\n\n  for (const block of blocks) {\n    const trimmedBlock = isTextBlock(context, block)\n      ? trimTextBlockWhitespace(block)\n      : block\n\n    if (mode === 'preserve') {\n      trimmedBlocks.push(trimmedBlock)\n\n      continue\n    }\n\n    if (mode === 'remove') {\n      if (isEmptyTextBlock(context, trimmedBlock)) {\n        continue\n      }\n\n      trimmedBlocks.push(trimmedBlock)\n\n      continue\n    }\n\n    if (mode === 'normalize') {\n      if (isEmptyTextBlock(context, trimmedBlock)) {\n        consecutiveEmptyCount++\n\n        if (consecutiveEmptyCount === 1) {\n          trimmedBlocks.push(trimmedBlock)\n        }\n\n        continue\n      }\n\n      trimmedBlocks.push(trimmedBlock)\n\n      consecutiveEmptyCount = 0\n    }\n  }\n\n  return trimmedBlocks\n}\n\nfunction isEmptyTextBlock(\n  context: {schema: Schema},\n  block: TypedObject,\n): boolean {\n  if (!isTextBlock(context, block)) {\n    return false\n  }\n\n  if (\n    block.children.some(\n      (child) => !isSpan(context, child) || child.text.trim() !== '',\n    )\n  ) {\n    return false\n  }\n\n  return true\n}\n\nfunction trimTextBlockWhitespace(\n  block: PortableTextTextBlock,\n): PortableTextTextBlock {\n  let index = 0\n\n  for (const child of block.children) {\n    if (!isMinimalSpan(child)) {\n      index++\n      continue\n    }\n\n    const nextChild = nextSpan(block, index)\n    const prevChild = prevSpan(block, index)\n\n    if (index === 0) {\n      child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n    }\n\n    if (index === block.children.length - 1) {\n      child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n    }\n\n    if (\n      /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) &&\n      nextChild &&\n      isMinimalSpan(nextChild) &&\n      /\\s/.test(nextChild.text.slice(0, 1))\n    ) {\n      child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n    }\n\n    if (\n      /\\s/.test(child.text.slice(0, 1)) &&\n      prevChild &&\n      isMinimalSpan(prevChild) &&\n      /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1)))\n    ) {\n      child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n    }\n\n    if (!child.text) {\n      block.children.splice(index, 1)\n    }\n\n    if (\n      prevChild &&\n      isEqual(prevChild.marks, child.marks) &&\n      isWhiteSpaceChar(child.text)\n    ) {\n      prevChild.text += ' '\n      block.children.splice(index, 1)\n    } else if (\n      nextChild &&\n      isEqual(nextChild.marks, child.marks) &&\n      isWhiteSpaceChar(child.text)\n    ) {\n      nextChild.text = ` ${nextChild.text}`\n      block.children.splice(index, 1)\n    }\n\n    index++\n  }\n\n  return block\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n} from '@portabletext/schema'\nimport {vercelStegaClean} from '@vercel/stega'\nimport {flatten} from 'lodash'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  HtmlDeserializerOptions,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {keyGenerator} from '../util/randomKey'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {flattenNestedBlocks} from './flatten-nested-blocks'\nimport {\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  tagName,\n} from './helpers'\nimport {preprocessors} from './preprocessors'\nimport {createRules} from './rules'\nimport {trimWhitespace} from './trim-whitespace'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  keyGenerator: () => string\n  schema: Schema\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  whitespaceMode: 'preserve' | 'remove' | 'normalize'\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(schema: Schema, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    const standardRules = createRules(schema, {\n      keyGenerator: options.keyGenerator,\n      matchers: options.matchers,\n    })\n    this.schema = schema\n    this.keyGenerator = options.keyGenerator ?? keyGenerator\n    this.rules = [...rules, ...standardRules]\n    this.whitespaceMode = unstable_whitespaceOnPasteMode\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.parseHtml = (html) => {\n      const cleanHTML = vercelStegaClean(html)\n      const doc = parseHtml(cleanHTML)\n\n      for (const processor of preprocessors) {\n        processor(cleanHTML, doc)\n      }\n\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n\n    const blocks = trimWhitespace(\n      {schema: this.schema},\n      this.whitespaceMode,\n      flattenNestedBlocks(\n        {schema: this.schema},\n        ensureRootIsBlocks(\n          this.schema,\n          this.deserializeElements(children) as Array<ArbitraryTypedObject>,\n        ),\n      ),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block) => isTextBlock({schema: this.schema}, block))\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return flatten(\n                block.children.map((child) => child.marks || []),\n              ).includes(def._key)\n            }),\n          )\n        })\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = this.schema.block.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (\n      elements: Node | Node[] | NodeList,\n    ): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node: TypedObject | Array<TypedObject> | undefined\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (\n        type !== 'array' &&\n        type !== 'object' &&\n        type !== 'null' &&\n        type !== 'undefined'\n      ) {\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`,\n        )\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        'listItem' in ret\n      ) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        ret.style === 'blockquote'\n      ) {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (\n    annotation: PlaceholderAnnotation,\n  ): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport type {TypedObject} from '../types'\nimport {keyGenerator} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n\n  /**\n   * Custom key generator function\n   */\n  keyGenerator?: () => string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<\n  TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>,\n  '_key'\n> & {\n  _key: string\n} {\n  const schema: Schema = {\n    block: {\n      name: options.blockTypeName || 'block',\n    },\n    span: {\n      name: 'span',\n    },\n    styles: [],\n    lists: [],\n    decorators: [],\n    annotations: [],\n    blockObjects: [],\n    inlineObjects: [],\n  }\n\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node\n      ? (node as TypedObject & {_key: string})\n      : {\n          ...node,\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        }\n  }\n\n  const block: Omit<\n    PortableTextTextBlock<TypedObject | PortableTextSpan>,\n    'style'\n  > = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isSpan({schema}, child) &&\n          isSpan({schema}, previousChild) &&\n          isEqual(previousChild.marks, child.marks)\n        ) {\n          if (\n            lastChild &&\n            lastChild === child &&\n            child.text === '' &&\n            block.children.length > 1\n          ) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = options.keyGenerator\n        ? options.keyGenerator()\n        : keyGenerator()\n\n      if (isSpan({schema}, child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) =>\n    usedMarkDefs.includes(markDef._key),\n  )\n\n  return block\n}\n","import {sanitySchemaToPortableTextSchema} from '@portabletext/sanity-bridge'\nimport type {Schema} from '@portabletext/schema'\nimport type {ArraySchemaType} from '@sanity/types'\nimport HtmlDeserializer from './HtmlDeserializer'\nimport type {HtmlDeserializerOptions, TypedObject} from './types'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param schemaType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  schemaType: ArraySchemaType | Schema,\n  options: HtmlDeserializerOptions = {},\n) {\n  const schema = isSanitySchema(schemaType)\n    ? sanitySchemaToPortableTextSchema(schemaType)\n    : schemaType\n\n  const deserializer = new HtmlDeserializer(schema, options)\n  return deserializer\n    .deserialize(html)\n    .map((block) => normalizeBlock(block, {keyGenerator: options.keyGenerator}))\n}\n\nexport type {ImageSchemaMatcher, SchemaMatchers} from './schema-matchers'\nexport type {ArbitraryTypedObject, DeserializerRule, HtmlParser} from './types'\nexport type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@portabletext/schema'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\nexport {randomKey} from './util/randomKey'\nexport {normalizeBlock}\nexport type {HtmlDeserializerOptions, TypedObject}\n\nfunction isSanitySchema(\n  schema: ArraySchemaType | Schema,\n): schema is ArraySchemaType {\n  return schema.hasOwnProperty('jsonType')\n}\n"],"names":["_","span","isEmphasis","isStrong","isUnderline","getListItemStyle","getListItemLevel","blocks","image","vercelStegaClean"],"mappings":"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"}},
    {"offset": {"line": 2406, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/to-html/dist/pt-to-html.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/escape.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/components/list.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/components/marks.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/warnings.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/components/unknown.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/components/defaults.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/components/merge.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/to-html/src/to-html.ts"],"sourcesContent":["const allowedProtocols = ['http', 'https', 'mailto', 'tel']\nconst charMap: Record<string, string> = {\n  '&': 'amp',\n  '<': 'lt',\n  '>': 'gt',\n  '\"': 'quot',\n  \"'\": '#x27',\n}\n\nexport function escapeHTML(str: string): string {\n  return replaceMultipleSpaces(str.replace(/[&<>\"']/g, (s) => `&${charMap[s]};`))\n}\n\nexport function replaceMultipleSpaces(str: string): string {\n  return str.replace(/ {2,}/g, (match: string) => `${'&nbsp;'.repeat(match.length - 1)} `)\n}\n\nexport function uriLooksSafe(uri: string): boolean {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  // Allow hash-links, absolute paths and \"same-protocol\" (//foo.bar) URLs\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  // If the URL does not contain a `:`, allow it\n  const colonIndex = url.indexOf(':')\n  if (colonIndex === -1) {\n    return true\n  }\n\n  // If the protocol is in the allowed list, treat it as OK\n  const proto = url.slice(0, colonIndex).toLowerCase()\n  if (allowedProtocols.indexOf(proto) !== -1) {\n    return true\n  }\n\n  // If the URL is `site/search?query=author:espen`, allow it\n  const queryIndex = url.indexOf('?')\n  if (queryIndex !== -1 && colonIndex > queryIndex) {\n    return true\n  }\n\n  // If the URL is `site/search#my:encoded:data`, allow it\n  const hashIndex = url.indexOf('#')\n  if (hashIndex !== -1 && colonIndex > hashIndex) {\n    return true\n  }\n\n  return false\n}\n","import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => `<ol>${children}</ol>`,\n  bullet: ({children}) => `<ul>${children}</ul>`,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => `<li>${children}</li>`\n","import type {TypedObject} from '@portabletext/types'\n\nimport {escapeHTML, uriLooksSafe} from '../escape'\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => {\n  const href = value?.href || ''\n  const looksSafe = uriLooksSafe(href)\n  return looksSafe ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children\n}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  'em': ({children}) => `<em>${children}</em>`,\n  'strong': ({children}) => `<strong>${children}</strong>`,\n  'code': ({children}) => `<code>${children}</code>`,\n  'underline': ({children}) => `<span style=\"text-decoration:underline\">${children}</span>`,\n  'strike-through': ({children}) => `<del>${children}</del>`,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  console.warn(message)\n}\n","import type {PortableTextHtmlComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nexport const DefaultUnknownType: PortableTextHtmlComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline\n    ? `<span style=\"display:none\">${warning}</span>`\n    : `<div style=\"display:none\">${warning}</div>`\n}\n\nexport const DefaultUnknownMark: PortableTextHtmlComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextHtmlComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return `<p>${children}</p>`\n}\n\nexport const DefaultUnknownList: PortableTextHtmlComponents['unknownList'] = ({children}) => {\n  return `<ul>${children}</ul>`\n}\n\nexport const DefaultUnknownListItem: PortableTextHtmlComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return `<li>${children}</li>`\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\n\nimport {escapeHTML} from '../escape'\nimport type {PortableTextBlockComponent, PortableTextHtmlComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): string => '<br/>'\n\nexport const defaultPortableTextBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => `<p>${children}</p>`,\n  blockquote: ({children}) => `<blockquote>${children}</blockquote>`,\n  h1: ({children}) => `<h1>${children}</h1>`,\n  h2: ({children}) => `<h2>${children}</h2>`,\n  h3: ({children}) => `<h3>${children}</h3>`,\n  h4: ({children}) => `<h4>${children}</h4>`,\n  h5: ({children}) => `<h5>${children}</h5>`,\n  h6: ({children}) => `<h6>${children}</h6>`,\n}\n\nexport const defaultComponents: PortableTextHtmlComponents = {\n  types: {},\n\n  block: defaultPortableTextBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n  escapeHTML: escapeHTML,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextHtmlComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n): PortableTextHtmlComponents {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextHtmlComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextHtmlComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextHtmlComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextHtmlComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextHtmlComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextHtmlComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextHtmlComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  nestLists,\n  spanToPlainText,\n  type ToolkitNestedPortableTextSpan,\n  type ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport type {\n  HtmlPortableTextList,\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextHtmlComponents,\n  PortableTextOptions,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function toHTML<B extends TypedObject = PortableTextBlock | ArbitraryTypedObject>(\n  value: B | B[],\n  options: PortableTextOptions = {},\n): string {\n  const {\n    components: componentOverrides,\n    onMissingComponent: missingComponentHandler = printWarning,\n  } = options\n\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(value) ? value : [value]\n  const nested = nestLists(blocks, 'html')\n  const components = componentOverrides\n    ? mergeComponents(defaultComponents, componentOverrides)\n    : defaultComponents\n\n  const renderNode = getNodeRenderer(components, handleMissingComponent)\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return rendered.join('')\n}\n\nconst getNodeRenderer = (\n  components: PortableTextHtmlComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): string {\n    const {node, index, isInline} = options\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node)\n    }\n\n    return renderCustomBlock(node, index, isInline)\n  }\n\n  function renderListItem(\n    node: PortableTextListItemBlock<PortableTextMarkDefinition, PortableTextSpan>,\n    index: number,\n  ): string {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const itemHandler = handler || components.unknownListItem\n\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block component says to use\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return itemHandler({value: node, index, isInline: false, renderNode, children})\n  }\n\n  function renderList(node: HtmlPortableTextList, index: number): string {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const list = handler || components.unknownList\n\n    if (list === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return list({value: node, index, isInline: false, renderNode, children: children.join('')})\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan): string {\n    const {markDef, markType, markKey} = node\n    const span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    if (span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return span({\n      text: spanToPlainText(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(''),\n    })\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, isInline: boolean): string {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const block = handler || components.unknownBlockStyle\n\n    if (block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return block({...props, value: props.node, renderNode})\n  }\n\n  function renderText(node: ToolkitTextNode): string {\n    if (node.text === '\\n') {\n      const hardBreak = components.hardBreak\n      return hardBreak ? hardBreak() : '\\n'\n    }\n\n    return components.escapeHTML(node.text)\n  }\n\n  function renderCustomBlock(value: TypedObject, index: number, isInline: boolean): string {\n    const node = components.types[value._type]\n\n    if (!node) {\n      handleMissingComponent(unknownTypeWarning(value._type), {\n        nodeType: 'block',\n        type: value._type,\n      })\n    }\n\n    const component = node || components.unknownType\n    return component({\n      value,\n      isInline,\n      index,\n      renderNode,\n    })\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(''),\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2662, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/patches/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/arrayInsert.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/array.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/number.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/object.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/primitive.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/string.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/applyPatch.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/patches/src/patches.ts"],"sourcesContent":["export const BEFORE = 'before'\nexport const AFTER = 'after'\n\nexport default function insert(\n  array: any[],\n  position: string,\n  index: number,\n  ...args: any[]\n) {\n  if (position !== BEFORE && position !== AFTER) {\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`,\n    )\n  }\n\n  const items = flatten(...args)\n\n  if (array.length === 0) {\n    return items\n  }\n\n  const len = array.length\n  const idx = Math.abs((len + index) % len) % len\n\n  const normalizedIdx = position === 'after' ? idx + 1 : idx\n\n  const copy = array.slice()\n  copy.splice(normalizedIdx, 0, ...flatten(items))\n  return copy\n}\n\nfunction flatten(...values: any[]) {\n  return values.reduce((prev, item) => prev.concat(item), [])\n}\n","import {findIndex} from 'lodash'\nimport applyPatch from './applyPatch'\nimport insert from './arrayInsert'\nimport type {JSONValue, Patch, PathSegment} from './types'\n\nfunction findTargetIndex(array: any[], pathSegment: PathSegment | undefined) {\n  if (typeof pathSegment === 'number') {\n    return pathSegment\n  }\n  const index = findIndex(array, pathSegment)\n  return index === -1 ? false : index\n}\n\nexport function applyPatchToArray(\n  value: Array<JSONValue>,\n  patch: Patch,\n): Array<JSONValue> | undefined {\n  const nextValue = value.slice() // make a copy for internal mutation\n\n  if (patch.path.length === 0) {\n    // its directed to me\n    if (patch.type === 'setIfMissing') {\n      if (!Array.isArray(patch.value)) {\n        throw new Error('Cannot set value of an array to a non-array')\n      }\n\n      return value === undefined ? patch.value : value\n    }\n\n    if (patch.type === 'set') {\n      if (!Array.isArray(patch.value)) {\n        throw new Error('Cannot set value of an array to a non-array')\n      }\n\n      return patch.value\n    }\n\n    if (patch.type === 'unset') {\n      return undefined\n    }\n\n    throw new Error(`Invalid array operation: ${patch.type}`)\n  }\n\n  const [head, ...tail] = patch.path\n\n  const index = findTargetIndex(value, head)\n\n  // If the given selector could not be found, return as-is\n  if (index === false) {\n    return nextValue\n  }\n\n  if (tail.length === 0) {\n    if (patch.type === 'insert') {\n      const {position, items} = patch\n      return insert(value, position, index, items)\n    } else if (patch.type === 'unset') {\n      if (typeof index !== 'number') {\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`,\n        )\n      }\n      nextValue.splice(index, 1)\n      return nextValue\n    }\n  }\n\n  // The patch is not directed to me\n  nextValue[index] = applyPatch(nextValue[index], {\n    ...patch,\n    path: tail,\n  }) as JSONValue\n\n  return nextValue\n}\n","import type {Patch} from './types'\n\nexport function applyPatchToNumber(value: number, patch: Patch) {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path\n        .map((path: any) => JSON.stringify(path))\n        .join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : value\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  if (patch.type === 'inc') {\n    if (typeof patch.value !== 'number') {\n      throw new Error('Cannot increment with a non-number')\n    }\n\n    return value + patch.value\n  }\n\n  if (patch.type === 'dec') {\n    if (typeof patch.value !== 'number') {\n      throw new Error('Cannot decrement with a non-number')\n    }\n\n    return value - patch.value\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for number. This is most likely a bug.`,\n  )\n}\n","import {clone, omit} from 'lodash'\nimport applyPatch from './applyPatch'\nimport type {JSONValue, Patch} from './types'\n\nexport function applyPatchToObject(\n  value: {[key: string]: JSONValue},\n  patch: Patch,\n): {[key: string]: JSONValue} | undefined {\n  const nextValue = clone(value)\n\n  if (patch.path.length === 0) {\n    // its directed to me\n    if (patch.type === 'set') {\n      if (\n        typeof patch.value === 'object' &&\n        patch.value !== null &&\n        !Array.isArray(patch.value)\n      ) {\n        return patch.value\n      }\n\n      throw new Error('Cannot set value of an object to a non-object')\n    }\n\n    if (patch.type === 'unset') {\n      return undefined\n    }\n\n    throw new Error(`Invalid object operation: ${patch.type}`)\n  }\n\n  // The patch is not directed to me\n  const [head, ...tail] = patch.path\n\n  if (typeof head !== 'string') {\n    throw new Error(`Expected field name to be a string, instead got: ${head}`)\n  }\n\n  if (tail.length === 0 && patch.type === 'unset') {\n    return omit(nextValue, head)\n  }\n\n  if (!(head in nextValue) && tail.length > 0) {\n    // The field does not exist on the object so we can just return the object\n    // as is\n    return nextValue\n  }\n\n  nextValue[head] = applyPatch(nextValue[head], {\n    ...patch,\n    path: tail,\n  }) as JSONValue\n\n  return nextValue\n}\n","import type {JSONValue, Patch} from './types'\n\nexport function applyPatchToUnknown(\n  value: unknown,\n  patch: Patch,\n): JSONValue | undefined {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path\n        .map((path: any) => JSON.stringify(path))\n        .join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : (value as JSONValue)\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for primitives. This is most likely a bug.`,\n  )\n}\n","import {applyPatches, parsePatch} from '@sanity/diff-match-patch'\nimport type {Patch} from './types'\n\nexport function applyPatchToString(value: string, patch: Patch) {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path.join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'diffMatchPatch') {\n    const [result] = applyPatches(parsePatch(patch.value), value, {\n      allowExceedingIndices: true,\n    })\n    return result\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : value\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for string. This is most likely a bug.`,\n  )\n}\n","import {applyPatchToArray} from './array'\nimport {applyPatchToNumber} from './number'\nimport {applyPatchToObject} from './object'\nimport {applyPatchToUnknown} from './primitive'\nimport {applyPatchToString} from './string'\nimport type {JSONValue, Patch} from './types'\n\n/** @beta */\nexport function applyAll<TValue>(value: TValue, patches: Array<Patch>): TValue {\n  return patches.reduce(applyPatch, value) as TValue\n}\n\nexport default function applyPatch(value: unknown, patch: Patch) {\n  if (Array.isArray(value)) {\n    return applyPatchToArray(value, patch)\n  }\n\n  if (typeof value === 'string') {\n    return applyPatchToString(value, patch)\n  }\n\n  if (isObject(value)) {\n    return applyPatchToObject(value, patch)\n  }\n\n  if (typeof value === 'number') {\n    return applyPatchToNumber(value, patch)\n  }\n\n  return applyPatchToUnknown(value, patch)\n}\n\nfunction isObject(value: unknown): value is {[key: string]: JSONValue} {\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\n}\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\nimport type {\n  DiffMatchPatch,\n  InsertPatch,\n  InsertPosition,\n  Path,\n  PathSegment,\n  SetIfMissingPatch,\n  SetPatch,\n  UnsetPatch,\n} from './types'\n\n/** @public */\nexport function setIfMissing(value: any, path: Path = []): SetIfMissingPatch {\n  return {\n    type: 'setIfMissing',\n    path,\n    value,\n  }\n}\n\n/** @public */\nexport function diffMatchPatch(\n  currentValue: string,\n  nextValue: string,\n  path: Path = [],\n): DiffMatchPatch {\n  const patches = makePatches(currentValue, nextValue)\n  const patch = stringifyPatches(patches)\n  return {type: 'diffMatchPatch', path, value: patch}\n}\n\n/** @public */\nexport function insert(\n  items: any[],\n  position: InsertPosition,\n  path: Path = [],\n): InsertPatch {\n  return {\n    type: 'insert',\n    path,\n    position,\n    items,\n  }\n}\n\n/** @public */\nexport function set(value: any, path: Path = []): SetPatch {\n  return {type: 'set', path, value}\n}\n\n/** @public */\nexport function unset(path: Path = []): UnsetPatch {\n  return {type: 'unset', path}\n}\n\n/** @internal */\nexport function prefixPath<T extends {path: Path}>(\n  patch: T,\n  segment: PathSegment,\n): T {\n  return {\n    ...patch,\n    path: [segment, ...patch.path],\n  }\n}\n"],"names":["insert"],"mappings":"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"}},
    {"offset": {"line": 2843, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/keyboard-shortcuts/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/keyboard-shortcuts/src/is-apple.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/keyboard-shortcuts/src/is-keyboard-shortcut.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/keyboard-shortcuts/src/keyboard-shortcuts.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/keyboard-shortcuts/src/common-shortcuts.ts"],"sourcesContent":["export const IS_APPLE =\n  typeof window !== 'undefined' &&\n  /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent)\n","import type {KeyboardEventDefinition} from './keyboard-event-definition'\n\n/**\n * Checks if a keyboard event matches a keyboard shortcut definition.\n */\nexport function isKeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  >,\n>(definition: KeyboardEventDefinition, event: TKeyboardEvent) {\n  if (!isCorrectModifiers(definition, event)) {\n    return false\n  }\n\n  if (\n    definition.code !== undefined &&\n    definition.code.toLowerCase() === event.code.toLowerCase()\n  ) {\n    return true\n  }\n\n  return (\n    definition.key !== undefined &&\n    definition.key.toLowerCase() === event.key.toLowerCase()\n  )\n}\n\nfunction isCorrectModifiers<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  >,\n>(definition: KeyboardEventDefinition, event: TKeyboardEvent) {\n  return (\n    (definition.ctrl === event.ctrlKey || definition.ctrl === undefined) &&\n    (definition.meta === event.metaKey || definition.meta === undefined) &&\n    (definition.shift === event.shiftKey || definition.shift === undefined) &&\n    (definition.alt === event.altKey || definition.alt === undefined)\n  )\n}\n","import {IS_APPLE} from './is-apple'\nimport {isKeyboardShortcut} from './is-keyboard-shortcut'\nimport type {KeyboardEventDefinition} from './keyboard-event-definition'\n\n/**\n * @public\n * Definition of a keyboard shortcut with platform-specific keyboard event\n * definitions.\n *\n * `default` keyboard event definitions are required while the `apple`\n * keyboard event definitions are optional.\n *\n * @example\n * ```typescript\n * const boldShortcut: KeyboardShortcutDefinition = {\n *   default: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: true,\n *     meta: false,\n *     shift: false,\n *   }],\n *   apple: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: false,\n *     meta: true,\n *     shift: false,\n *   }],\n * }\n * ```\n */\nexport type KeyboardShortcutDefinition = {\n  default: ReadonlyArray<KeyboardEventDefinition>\n  apple?: ReadonlyArray<KeyboardEventDefinition>\n}\n\n/**\n * @public\n * A resolved keyboard shortcut for the current platform that has been\n * processed by `createKeyboardShortcut(...)` to select the appropriate\n * platform-specific key combination. The `guard` function determines if the\n * shortcut applies to the current `KeyboardEvent`, while `keys` contains the\n * display-friendly key combination for the current platform.\n */\nexport type KeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n> = {\n  guard: (event: TKeyboardEvent) => boolean\n  keys: ReadonlyArray<string>\n}\n\n/**\n * @public\n * Creates a `KeyboardShortcut` from a `KeyboardShortcutDefinition`.\n *\n * `default` keyboard event definitions are required while the `apple`\n * keyboard event definitions are optional.\n *\n * @example\n * ```typescript\n * const shortcut = createKeyboardShortcut({\n *   default: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: true,\n *     meta: false,\n *     shift: false,\n *   }],\n *   apple: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: false,\n *     meta: true,\n *     shift: false,\n *   }],\n * })\n * ```\n */\nexport function createKeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n>(definition: KeyboardShortcutDefinition): KeyboardShortcut<TKeyboardEvent> {\n  if (IS_APPLE) {\n    const appleDefinition = definition.apple ?? definition.default\n    const firstDefinition = appleDefinition.at(0)\n\n    return {\n      guard: (event) =>\n        appleDefinition.some((definition) =>\n          isKeyboardShortcut(definition, event),\n        ),\n      keys: [\n        ...(firstDefinition?.meta ? [''] : []),\n        ...(firstDefinition?.ctrl ? ['Ctrl'] : []),\n        ...(firstDefinition?.alt ? ['Option'] : []),\n        ...(firstDefinition?.shift ? ['Shift'] : []),\n        ...(firstDefinition?.key !== undefined\n          ? [firstDefinition.key]\n          : firstDefinition?.code !== undefined\n            ? [firstDefinition.code]\n            : []),\n      ],\n    }\n  }\n\n  const firstDefinition = definition.default.at(0)\n\n  return {\n    guard: (event) =>\n      definition.default.some((definition) =>\n        isKeyboardShortcut(definition, event),\n      ),\n    keys: [\n      ...(firstDefinition?.meta ? ['Meta'] : []),\n      ...(firstDefinition?.ctrl ? ['Ctrl'] : []),\n      ...(firstDefinition?.alt ? ['Alt'] : []),\n      ...(firstDefinition?.shift ? ['Shift'] : []),\n      ...(firstDefinition?.key !== undefined\n        ? [firstDefinition.key]\n        : firstDefinition?.code !== undefined\n          ? [firstDefinition.code]\n          : []),\n    ],\n  }\n}\n","import {createKeyboardShortcut} from './keyboard-shortcuts'\n\n/**\n * @public\n */\nexport const bold = createKeyboardShortcut({\n  default: [\n    {\n      key: 'B',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'B',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const italic = createKeyboardShortcut({\n  default: [\n    {\n      key: 'I',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'I',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const code = createKeyboardShortcut({\n  default: [\n    {\n      key: \"'\",\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: \"'\",\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const underline = createKeyboardShortcut({\n  default: [\n    {\n      key: 'U',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'U',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const strikeThrough = createKeyboardShortcut({\n  default: [\n    {\n      key: 'X',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n  apple: [\n    {\n      key: 'X',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: true,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const link = createKeyboardShortcut({\n  default: [\n    {\n      key: 'K',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'K',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const normal = createKeyboardShortcut({\n  default: [\n    {\n      key: '0',\n      code: 'Digit0',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '0',\n      code: 'Numpad0',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '0',\n      code: 'Digit0',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '0',\n      code: 'Numpad0',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h1 = createKeyboardShortcut({\n  default: [\n    {\n      key: '1',\n      code: 'Digit1',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '1',\n      code: 'Numpad1',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '1',\n      code: 'Digit1',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '1',\n      code: 'Numpad1',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h2 = createKeyboardShortcut({\n  default: [\n    {\n      key: '2',\n      code: 'Digit2',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '2',\n      code: 'Numpad2',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '2',\n      code: 'Digit2',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '2',\n      code: 'Numpad2',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h3 = createKeyboardShortcut({\n  default: [\n    {\n      key: '3',\n      code: 'Digit3',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '3',\n      code: 'Numpad3',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '3',\n      code: 'Digit3',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '3',\n      code: 'Numpad3',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h4 = createKeyboardShortcut({\n  default: [\n    {\n      key: '4',\n      code: 'Digit4',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '4',\n      code: 'Numpad4',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '4',\n      code: 'Digit4',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '4',\n      code: 'Numpad4',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h5 = createKeyboardShortcut({\n  default: [\n    {\n      key: '5',\n      code: 'Digit5',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '5',\n      code: 'Numpad5',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '5',\n      code: 'Digit5',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '5',\n      code: 'Numpad5',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h6 = createKeyboardShortcut({\n  default: [\n    {\n      key: '6',\n      code: 'Digit6',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '6',\n      code: 'Numpad6',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '6',\n      code: 'Digit6',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '6',\n      code: 'Numpad6',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const blockquote = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Q',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const undo = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const redo = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Y',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n  apple: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: true,\n    },\n  ],\n})\n"],"names":["firstDefinition","definition"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,WACX,OAAO,yCAAW,OAClB,uBAAuB,IAAA,CAAK,OAAO,SAAA,CAAU,SAAS;ACGjD,SAAS,mBAQd,UAAA,EAAqC,KAAA,EAAuB;IAC5D,OAAK,mBAAmB,YAAY,KAAK,IAKvC,WAAW,IAAA,KAAS,KAAA,KACpB,WAAW,IAAA,CAAK,WAAA,CAAA,MAAkB,MAAM,IAAA,CAAK,WAAA,KAEtC,CAAA,IAIP,WAAW,GAAA,KAAQ,KAAA,KACnB,WAAW,GAAA,CAAI,WAAA,CAAA,MAAkB,MAAM,GAAA,CAAI,WAAA,CAAA,IAZpC,CAAA;AAcX;AAEA,SAAS,mBAQP,UAAA,EAAqC,KAAA,EAAuB;IAC5D,OAAA,CACG,WAAW,IAAA,KAAS,MAAM,OAAA,IAAW,WAAW,IAAA,KAAS,KAAA,CAAA,KAAA,CACzD,WAAW,IAAA,KAAS,MAAM,OAAA,IAAW,WAAW,IAAA,KAAS,KAAA,CAAA,KAAA,CACzD,WAAW,KAAA,KAAU,MAAM,QAAA,IAAY,WAAW,KAAA,KAAU,KAAA,CAAA,KAAA,CAC5D,WAAW,GAAA,KAAQ,MAAM,MAAA,IAAU,WAAW,GAAA,KAAQ,KAAA,CAAA;AAE3D;ACuCO,SAAS,uBAQd,UAAA,EAA0E;IAC1E,IAAI,UAAU;QACZ,MAAM,kBAAkB,WAAW,KAAA,IAAS,WAAW,OAAA,EACjDA,mBAAkB,gBAAgB,EAAA,CAAG,CAAC;QAE5C,OAAO;YACL,OAAO,CAAC,QACN,gBAAgB,IAAA,CAAK,CAACC,cACpB,mBAAmBA,aAAY,KAAK;YAExC,MAAM;mBACAD,kBAAiB,OAAO;oBAAC,QAAG;iBAAA,GAAI,CAAA,CAAA;mBAChCA,kBAAiB,OAAO;oBAAC,MAAM;iBAAA,GAAI,CAAA,CAAA;mBACnCA,kBAAiB,MAAM;oBAAC,QAAQ;iBAAA,GAAI,CAAA,CAAA;mBACpCA,kBAAiB,QAAQ;oBAAC,OAAO;iBAAA,GAAI,CAAA,CAAA;mBACrCA,kBAAiB,QAAQ,KAAA,IACzB;oBAACA,iBAAgB,GAAG;iBAAA,GACpBA,kBAAiB,SAAS,KAAA,IACxB;oBAACA,iBAAgB,IAAI;iBAAA,GACrB,CAAA,CAAA;aAAC;QACT;IAEJ;IAEA,MAAM,kBAAkB,WAAW,OAAA,CAAQ,EAAA,CAAG,CAAC;IAE/C,OAAO;QACL,OAAO,CAAC,QACN,WAAW,OAAA,CAAQ,IAAA,CAAK,CAACC,cACvB,mBAAmBA,aAAY,KAAK;QAExC,MAAM;eACA,iBAAiB,OAAO;gBAAC,MAAM;aAAA,GAAI,CAAA,CAAA;eACnC,iBAAiB,OAAO;gBAAC,MAAM;aAAA,GAAI,CAAA,CAAA;eACnC,iBAAiB,MAAM;gBAAC,KAAK;aAAA,GAAI,CAAA,CAAA;eACjC,iBAAiB,QAAQ;gBAAC,OAAO;aAAA,GAAI,CAAA,CAAA;eACrC,iBAAiB,QAAQ,KAAA,IACzB;gBAAC,gBAAgB,GAAG;aAAA,GACpB,iBAAiB,SAAS,KAAA,IACxB;gBAAC,gBAAgB,IAAI;aAAA,GACrB,CAAA,CAAA;SAAC;IACT;AAEJ;ACnIO,MAAM,OAAO,uBAAuB;IACzC,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,SAAS,uBAAuB;IAC3C,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,OAAO,uBAAuB;IACzC,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,YAAY,uBAAuB;IAC9C,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,gBAAgB,uBAAuB;IAClD,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,OAAO,uBAAuB;IACzC,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,SAAS,uBAAuB;IAC3C,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,KAAK,uBAAuB;IACvC,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,KAAK,uBAAuB;IACvC,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,KAAK,uBAAuB;IACvC,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,KAAK,uBAAuB;IACvC,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,KAAK,uBAAuB;IACvC,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,KAAK,uBAAuB;IACvC,SAAS;QACP;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,MAAM;YACN,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,aAAa,uBAAuB;IAC/C,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,OAAO,uBAAuB;IACzC,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC,GAKY,OAAO,uBAAuB;IACzC,SAAS;QACP;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;QAET;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;IAEF,OAAO;QACL;YACE,KAAK;YACL,KAAK,CAAA;YACL,MAAM,CAAA;YACN,MAAM,CAAA;YACN,OAAO,CAAA;QAAA;KACT;AAEJ,CAAC"}},
    {"offset": {"line": 3371, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-one-line/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-one-line/src/plugin.one-line.tsx"],"sourcesContent":["import {useEditor} from '@portabletext/editor'\nimport {defineBehavior, raise} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\nimport * as utils from '@portabletext/editor/utils'\nimport {useEffect} from 'react'\n\nconst oneLineBehaviors = [\n  /**\n   * Hitting Enter on an expanded selection should just delete that selection\n   * without causing a line break.\n   */\n  defineBehavior({\n    on: 'insert.break',\n    guard: ({snapshot}) =>\n      snapshot.context.selection && selectors.isSelectionExpanded(snapshot)\n        ? {selection: snapshot.context.selection}\n        : false,\n    actions: [(_, {selection}) => [raise({type: 'delete', at: selection})]],\n  }),\n  /**\n   * All other cases of `insert.break` should be aborted.\n   */\n  defineBehavior({\n    on: 'insert.break',\n    actions: [],\n  }),\n  /**\n   * `insert.block` `before` or `after` is not allowed in a one-line editor.\n   */\n  defineBehavior({\n    on: 'insert.block',\n    guard: ({event}) =>\n      event.placement === 'before' || event.placement === 'after',\n    actions: [],\n  }),\n  /**\n   * An ordinary `insert.block` is acceptable if it's a text block. In that\n   * case it will get merged into the existing text block.\n   */\n  defineBehavior({\n    on: 'insert.block',\n    guard: ({snapshot, event}) => {\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (\n        !focusTextBlock ||\n        !utils.isTextBlock(snapshot.context, event.block)\n      ) {\n        return false\n      }\n\n      return event.placement !== 'auto' || event.select !== 'end'\n    },\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'insert.block',\n          block: event.block,\n          placement: 'auto',\n          select: 'end',\n        }),\n      ],\n    ],\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all\n   * end up with a falsy guard.\n   */\n  defineBehavior({\n    on: 'insert.block',\n    guard: ({snapshot, event}) => {\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (!focusTextBlock) {\n        return true\n      }\n\n      return !utils.isTextBlock(snapshot.context, event.block)\n    },\n    actions: [],\n  }),\n  /**\n   * If multiple blocks are inserted, then the non-text blocks are filtered out\n   * and the text blocks are merged into one block\n   */\n  defineBehavior({\n    on: 'insert.blocks',\n    guard: ({snapshot, event}) => {\n      const textBlocks = event.blocks.filter((block) =>\n        utils.isTextBlock(snapshot.context, block),\n      )\n\n      if (textBlocks.length === 0) {\n        return false\n      }\n\n      return textBlocks.reduce((targetBlock, incomingBlock) => {\n        return utils.mergeTextBlocks({\n          context: snapshot.context,\n          targetBlock,\n          incomingBlock,\n        })\n      })\n    },\n    actions: [\n      // `insert.block` is raised so the Behavior above can handle the\n      // insertion\n      (_, block) => [raise({type: 'insert.block', block, placement: 'auto'})],\n    ],\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.blocks` in case the Behavior above\n   * ends up with a falsy guard.\n   */\n  defineBehavior({\n    on: 'insert.blocks',\n    actions: [],\n  }),\n]\n\n/**\n * @public\n * Restrict the editor to one line. The plugin takes care of blocking\n * `insert.break` events and smart handling of other `insert.*` events.\n *\n * Place it with as high priority as possible to make sure other plugins don't\n * overwrite `insert.*` events before this plugin gets a chance to do so.\n */\nexport function OneLinePlugin() {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const unregisterBehaviors = oneLineBehaviors.map((behavior) =>\n      editor.registerBehavior({behavior}),\n    )\n\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors) {\n        unregisterBehavior()\n      }\n    }\n  }, [editor])\n\n  return null\n}\n"],"names":["oneLineBehaviors","defineBehavior","on","guard","snapshot","context","selection","selectors","isSelectionExpanded","actions","_","raise","type","at","event","placement","getFocusTextBlock","utils","isTextBlock","block","select","textBlocks","blocks","filter","length","reduce","targetBlock","incomingBlock","mergeTextBlocks","OneLinePlugin","$","_c","editor","useEditor","t0","t1","unregisterBehaviors","map","behavior","registerBehavior","unregisterBehavior","useEffect"],"mappings":"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"}},
    {"offset": {"line": 3497, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-character-pair-decorator/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-character-pair-decorator/src/regex.character-pair.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-character-pair-decorator/src/behavior.character-pair-decorator.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-character-pair-decorator/src/plugin.character-pair-decorator.ts"],"sourcesContent":["export function createCharacterPairRegex(char: string, amount: number) {\n  // Negative lookbehind: Ensures that the matched sequence is not preceded by the same character\n  const prePrefix = `(?<!\\\\${char})`\n\n  // Repeats the character `amount` times\n  const prefix = `\\\\${char}`.repeat(Math.max(amount, 1))\n\n  // Negative lookahead: Ensures that the opening pair (**, *, etc.) is not followed by a space\n  const postPrefix = `(?!\\\\s)`\n\n  // Captures the content inside the pair\n  const content = `([^${char}\\\\n]+?)`\n\n  // Negative lookbehind: Ensures that the content is not followed by a space\n  const preSuffix = `(?<!\\\\s)`\n\n  // Repeats the character `amount` times\n  const suffix = `\\\\${char}`.repeat(Math.max(amount, 1))\n\n  // Negative lookahead: Ensures that the matched sequence is not followed by the same character\n  const postSuffix = `(?!\\\\${char})`\n\n  return `${prePrefix}${prefix}${postPrefix}${content}${preSuffix}${suffix}${postSuffix}`\n}\n","import type {BlockOffset, EditorContext} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\nimport * as utils from '@portabletext/editor/utils'\nimport {createCharacterPairRegex} from './regex.character-pair'\n\nexport function createCharacterPairDecoratorBehavior(config: {\n  decorator: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  pair: {char: string; amount: number}\n  onDecorate: (offset: BlockOffset) => void\n}) {\n  if (config.pair.amount < 1) {\n    console.warn(\n      `The amount of characters in the pair should be greater than 0`,\n    )\n  }\n\n  const pairRegex = createCharacterPairRegex(\n    config.pair.char,\n    config.pair.amount,\n  )\n  const regEx = new RegExp(`(${pairRegex})$`)\n\n  return defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      if (config.pair.amount < 1) {\n        return false\n      }\n\n      const decorator = config.decorator({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (decorator === undefined) {\n        return false\n      }\n\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const selectionStartPoint = selectors.getSelectionStartPoint(snapshot)\n      const selectionStartOffset = selectionStartPoint\n        ? utils.spanSelectionPointToBlockOffset({\n            context: snapshot.context,\n            selectionPoint: selectionStartPoint,\n          })\n        : undefined\n\n      if (!focusTextBlock || !selectionStartOffset) {\n        return false\n      }\n\n      const textBefore = selectors.getBlockTextBefore(snapshot)\n      const newText = `${textBefore}${event.text}`\n      const textToDecorate = newText.match(regEx)?.at(0)\n\n      if (textToDecorate === undefined) {\n        return false\n      }\n\n      const prefixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length = 4\n          offset: newText.length - textToDecorate.length,\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length + \"*\".length * 2 = 6\n          offset:\n            newText.length -\n            textToDecorate.length +\n            config.pair.char.length * config.pair.amount,\n        },\n      }\n\n      const suffixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length - 2 = 9\n          offset:\n            selectionStartOffset.offset +\n            event.text.length -\n            config.pair.char.length * config.pair.amount,\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length = 11\n          offset: selectionStartOffset.offset + event.text.length,\n        },\n      }\n\n      // If the prefix is more than one character, then we need to check if\n      // there is an inline object inside it\n      if (prefixOffsets.focus.offset - prefixOffsets.anchor.offset > 1) {\n        const prefixSelection = utils.blockOffsetsToSelection({\n          context: snapshot.context,\n          offsets: prefixOffsets,\n        })\n        const inlineObjectBeforePrefixFocus = selectors.getPreviousInlineObject(\n          {\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: prefixSelection\n                ? {\n                    anchor: prefixSelection.focus,\n                    focus: prefixSelection.focus,\n                  }\n                : null,\n            },\n          },\n        )\n        const inlineObjectBeforePrefixFocusOffset =\n          inlineObjectBeforePrefixFocus\n            ? utils.childSelectionPointToBlockOffset({\n                context: snapshot.context,\n                selectionPoint: {\n                  path: inlineObjectBeforePrefixFocus.path,\n                  offset: 0,\n                },\n              })\n            : undefined\n\n        if (\n          inlineObjectBeforePrefixFocusOffset &&\n          inlineObjectBeforePrefixFocusOffset.offset >\n            prefixOffsets.anchor.offset &&\n          inlineObjectBeforePrefixFocusOffset.offset <\n            prefixOffsets.focus.offset\n        ) {\n          return false\n        }\n      }\n\n      // If the suffix is more than one character, then we need to check if\n      // there is an inline object inside it\n      if (suffixOffsets.focus.offset - suffixOffsets.anchor.offset > 1) {\n        const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n        const previousInlineObjectOffset = previousInlineObject\n          ? utils.childSelectionPointToBlockOffset({\n              context: snapshot.context,\n              selectionPoint: {\n                path: previousInlineObject.path,\n                offset: 0,\n              },\n            })\n          : undefined\n\n        if (\n          previousInlineObjectOffset &&\n          previousInlineObjectOffset.offset > suffixOffsets.anchor.offset &&\n          previousInlineObjectOffset.offset < suffixOffsets.focus.offset\n        ) {\n          return false\n        }\n      }\n\n      return {\n        prefixOffsets,\n        suffixOffsets,\n        decorator,\n      }\n    },\n    actions: [\n      // Insert the text as usual in its own undo step\n      ({event}) => [forward(event)],\n      (_, {prefixOffsets, suffixOffsets, decorator}) => [\n        // Decorate the text between the prefix and suffix\n        raise({\n          type: 'decorator.add',\n          decorator,\n          at: {\n            anchor: prefixOffsets.focus,\n            focus: suffixOffsets.anchor,\n          },\n        }),\n        // Delete the suffix\n        raise({\n          type: 'delete.text',\n          at: suffixOffsets,\n        }),\n        // Delete the prefix\n        raise({\n          type: 'delete.text',\n          at: prefixOffsets,\n        }),\n        // Toggle the decorator off so the next inserted text isn't emphasized\n        raise({\n          type: 'decorator.remove',\n          decorator,\n        }),\n        effect(() => {\n          config.onDecorate({\n            ...suffixOffsets.anchor,\n            offset:\n              suffixOffsets.anchor.offset -\n              (prefixOffsets.focus.offset - prefixOffsets.anchor.offset),\n          })\n        }),\n      ],\n    ],\n  })\n}\n","import type {BlockOffset, Editor, EditorContext} from '@portabletext/editor'\nimport {useEditor} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n} from '@portabletext/editor/behaviors'\nimport * as utils from '@portabletext/editor/utils'\nimport {useActorRef} from '@xstate/react'\nimport {isDeepEqual} from 'remeda'\nimport {\n  assign,\n  fromCallback,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport {createCharacterPairDecoratorBehavior} from './behavior.character-pair-decorator'\n\n/**\n * @public\n */\nexport function CharacterPairDecoratorPlugin(props: {\n  decorator: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  pair: {char: string; amount: number}\n}) {\n  const editor = useEditor()\n\n  useActorRef(decoratorPairMachine, {\n    input: {\n      editor,\n      decorator: props.decorator,\n      pair: props.pair,\n    },\n  })\n\n  return null\n}\n\ntype DecoratorPairEvent =\n  | {\n      type: 'decorator.add'\n      blockOffset: BlockOffset\n    }\n  | {\n      type: 'selection'\n      blockOffsets?: {\n        anchor: BlockOffset\n        focus: BlockOffset\n      }\n    }\n  | {\n      type: 'delete.backward'\n    }\n\nconst decorateListener: CallbackLogicFunction<\n  AnyEventObject,\n  DecoratorPairEvent,\n  {\n    decorator: ({\n      context,\n      schema,\n    }: {\n      context: Pick<EditorContext, 'schema'>\n      /**\n       * @deprecated Use `context.schema` instead\n       */\n      schema: EditorContext['schema']\n    }) => string | undefined\n    editor: Editor\n    pair: {char: string; amount: number}\n  }\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: createCharacterPairDecoratorBehavior({\n      decorator: input.decorator,\n      pair: input.pair,\n      onDecorate: (offset) => {\n        sendBack({type: 'decorator.add', blockOffset: offset})\n      },\n    }),\n  })\n\n  return unregister\n}\n\nconst selectionListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  DecoratorPairEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'select',\n      guard: ({snapshot, event}) => {\n        if (!event.at) {\n          return {blockOffsets: undefined}\n        }\n\n        const anchor = utils.spanSelectionPointToBlockOffset({\n          context: snapshot.context,\n          selectionPoint: event.at.anchor,\n        })\n        const focus = utils.spanSelectionPointToBlockOffset({\n          context: snapshot.context,\n          selectionPoint: event.at.focus,\n        })\n\n        if (!anchor || !focus) {\n          return {blockOffsets: undefined}\n        }\n\n        return {\n          blockOffsets: {\n            anchor,\n            focus,\n          },\n        }\n      },\n      actions: [\n        ({event}, {blockOffsets}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              sendBack({type: 'selection', blockOffsets})\n            },\n          },\n          forward(event),\n        ],\n      ],\n    }),\n  })\n\n  return unregister\n}\n\nconst deleteBackwardListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  DecoratorPairEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'delete.backward',\n      actions: [\n        () => [\n          raise({\n            type: 'history.undo',\n          }),\n          effect(() => {\n            sendBack({type: 'delete.backward'})\n          }),\n        ],\n      ],\n    }),\n  })\n\n  return unregister\n}\n\nconst decoratorPairMachine = setup({\n  types: {\n    context: {} as {\n      decorator: ({\n        context,\n        schema,\n      }: {\n        context: Pick<EditorContext, 'schema'>\n        /**\n         * @deprecated Use `context.schema` instead\n         */\n        schema: EditorContext['schema']\n      }) => string | undefined\n      editor: Editor\n      offsetAfterDecorator?: BlockOffset\n      pair: {char: string; amount: number}\n    },\n    input: {} as {\n      decorator: ({\n        context,\n        schema,\n      }: {\n        context: Pick<EditorContext, 'schema'>\n        /**\n         * @deprecated Use `context.schema` instead\n         */\n        schema: EditorContext['schema']\n      }) => string | undefined\n      editor: Editor\n      pair: {char: string; amount: number}\n    },\n    events: {} as DecoratorPairEvent,\n  },\n  actors: {\n    'decorate listener': fromCallback(decorateListener),\n    'delete.backward listener': fromCallback(deleteBackwardListenerCallback),\n    'selection listener': fromCallback(selectionListenerCallback),\n  },\n}).createMachine({\n  id: 'decorator pair',\n  context: ({input}) => ({\n    decorator: input.decorator,\n    editor: input.editor,\n    pair: input.pair,\n  }),\n  initial: 'idle',\n  states: {\n    'idle': {\n      invoke: [\n        {\n          src: 'decorate listener',\n          input: ({context}) => ({\n            decorator: context.decorator,\n            editor: context.editor,\n            pair: context.pair,\n          }),\n        },\n      ],\n      on: {\n        'decorator.add': {\n          target: 'decorator added',\n          actions: assign({\n            offsetAfterDecorator: ({event}) => event.blockOffset,\n          }),\n        },\n      },\n    },\n    'decorator added': {\n      exit: [\n        assign({\n          offsetAfterDecorator: undefined,\n        }),\n      ],\n      invoke: [\n        {\n          src: 'selection listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n        {\n          src: 'delete.backward listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n      ],\n      on: {\n        'selection': {\n          target: 'idle',\n          guard: ({context, event}) => {\n            const selectionChanged = !isDeepEqual(\n              {\n                anchor: context.offsetAfterDecorator,\n                focus: context.offsetAfterDecorator,\n              },\n              event.blockOffsets,\n            )\n\n            return selectionChanged\n          },\n        },\n        'delete.backward': {\n          target: 'idle',\n        },\n      },\n    },\n  },\n})\n"],"names":["createCharacterPairRegex","char","amount","prePrefix","prefix","repeat","Math","max","postPrefix","content","preSuffix","suffix","postSuffix","createCharacterPairDecoratorBehavior","config","pair","console","warn","pairRegex","regEx","RegExp","defineBehavior","on","guard","snapshot","event","decorator","context","schema","undefined","focusTextBlock","selectors","getFocusTextBlock","selectionStartPoint","getSelectionStartPoint","selectionStartOffset","utils","spanSelectionPointToBlockOffset","selectionPoint","newText","getBlockTextBefore","text","textToDecorate","match","at","prefixOffsets","anchor","path","offset","length","focus","suffixOffsets","prefixSelection","blockOffsetsToSelection","offsets","inlineObjectBeforePrefixFocus","getPreviousInlineObject","selection","inlineObjectBeforePrefixFocusOffset","childSelectionPointToBlockOffset","previousInlineObject","previousInlineObjectOffset","actions","forward","_","raise","type","effect","onDecorate","CharacterPairDecoratorPlugin","props","$","_c","editor","useEditor","t0","input","useActorRef","decoratorPairMachine","decorateListener","sendBack","registerBehavior","behavior","blockOffset","selectionListenerCallback","blockOffsets","deleteBackwardListenerCallback","setup","types","events","actors","fromCallback","createMachine","id","initial","states","invoke","src","target","assign","offsetAfterDecorator","exit","isDeepEqual"],"mappings":"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"}},
    {"offset": {"line": 3804, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-input-rule/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-input-rule/src/input-rule.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-input-rule/src/input-rule-match-location.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-input-rule/src/plugin.input-rule.tsx","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-input-rule/src/text-transform-rule.ts"],"sourcesContent":["import type {BlockPath, PortableTextBlock} from '@portabletext/editor'\nimport type {\n  BehaviorActionSet,\n  BehaviorGuard,\n} from '@portabletext/editor/behaviors'\nimport type {InputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * Match found in the text after the insertion\n * @alpha\n */\nexport type InputRuleMatch = InputRuleMatchLocation & {\n  groupMatches: Array<InputRuleMatchLocation>\n}\n\n/**\n * @alpha\n */\nexport type InputRuleEvent = {\n  type: 'custom.input rule'\n  /**\n   * Matches found by the input rule\n   */\n  matches: Array<InputRuleMatch>\n  /**\n   * The text before the insertion\n   */\n  textBefore: string\n  /**\n   * The text is destined to be inserted\n   */\n  textInserted: string\n  /**\n   * The block where the insertion takes place\n   */\n  focusBlock: {\n    path: BlockPath\n    node: PortableTextBlock\n  }\n}\n\n/**\n * @alpha\n */\nexport type InputRuleGuard<TGuardResponse = true> = BehaviorGuard<\n  InputRuleEvent,\n  TGuardResponse\n>\n\n/**\n * @alpha\n */\nexport type InputRule<TGuardResponse = true> = {\n  on: RegExp\n  guard?: InputRuleGuard<TGuardResponse>\n  actions: Array<BehaviorActionSet<InputRuleEvent, TGuardResponse>>\n}\n\n/**\n * @alpha\n */\nexport function defineInputRule<TGuardResponse = true>(\n  config: InputRule<TGuardResponse>,\n): InputRule<TGuardResponse> {\n  return config\n}\n","import type {\n  BlockOffset,\n  BlockPath,\n  EditorSelection,\n  EditorSnapshot,\n} from '@portabletext/editor'\nimport {\n  getNextInlineObjects,\n  getPreviousInlineObjects,\n} from '@portabletext/editor/selectors'\nimport {blockOffsetToSpanSelectionPoint} from '@portabletext/editor/utils'\n\nexport type InputRuleMatchLocation = {\n  /**\n   * The matched text\n   */\n  text: string\n  /**\n   * Estimated selection of where in the original text the match is located.\n   * The selection is estimated since the match is found in the text after\n   * insertion.\n   */\n  selection: NonNullable<EditorSelection>\n  /**\n   * Block offsets of the match in the text after the insertion\n   */\n  targetOffsets: {\n    anchor: BlockOffset\n    focus: BlockOffset\n    backward: boolean\n  }\n}\n\nexport function getInputRuleMatchLocation({\n  match,\n  adjustIndexBy,\n  snapshot,\n  focusBlock,\n  originalTextBefore,\n}: {\n  match: [string, number, number]\n  adjustIndexBy: number\n  snapshot: EditorSnapshot\n  focusBlock: {\n    path: BlockPath\n  }\n  originalTextBefore: string\n}): InputRuleMatchLocation | undefined {\n  const [text, start, end] = match\n  const adjustedIndex = start + adjustIndexBy\n\n  const targetOffsets = {\n    anchor: {\n      path: focusBlock.path,\n      offset: adjustedIndex,\n    },\n    focus: {\n      path: focusBlock.path,\n      offset: adjustedIndex + end - start,\n    },\n    backward: false,\n  }\n  const normalizedOffsets = {\n    anchor: {\n      path: focusBlock.path,\n      offset: Math.min(targetOffsets.anchor.offset, originalTextBefore.length),\n    },\n    focus: {\n      path: focusBlock.path,\n      offset: Math.min(targetOffsets.focus.offset, originalTextBefore.length),\n    },\n    backward: false,\n  }\n\n  const anchorBackwards = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: normalizedOffsets.anchor,\n    direction: 'backward',\n  })\n  const focusForwards = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: normalizedOffsets.focus,\n    direction: 'forward',\n  })\n\n  if (!anchorBackwards || !focusForwards) {\n    return undefined\n  }\n\n  const selection = {\n    anchor: anchorBackwards,\n    focus: focusForwards,\n  }\n\n  const inlineObjectsAfterMatch = getNextInlineObjects({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selection.anchor,\n        focus: selection.anchor,\n      },\n    },\n  })\n  const inlineObjectsBefore = getPreviousInlineObjects(snapshot)\n\n  if (\n    inlineObjectsAfterMatch.some((inlineObjectAfter) =>\n      inlineObjectsBefore.some(\n        (inlineObjectBefore) =>\n          inlineObjectAfter.node._key === inlineObjectBefore.node._key,\n      ),\n    )\n  ) {\n    return undefined\n  }\n\n  return {\n    text,\n    selection,\n    targetOffsets,\n  }\n}\n","import {useEditor, type BlockOffset, type Editor} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n  type BehaviorAction,\n} from '@portabletext/editor/behaviors'\nimport {\n  getBlockOffsets,\n  getBlockTextBefore,\n  getFocusBlock,\n} from '@portabletext/editor/selectors'\nimport {isSelectionCollapsed} from '@portabletext/editor/utils'\nimport {useActorRef} from '@xstate/react'\nimport {\n  fromCallback,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport type {InputRule, InputRuleMatch} from './input-rule'\nimport {getInputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * @alpha\n */\nexport function defineInputRuleBehavior(config: {\n  rules: Array<InputRule<any>>\n  onApply?: ({\n    endOffsets,\n  }: {\n    endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n  }) => void\n}) {\n  return defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event, dom}) => {\n      if (\n        !snapshot.context.selection ||\n        !isSelectionCollapsed(snapshot.context.selection)\n      ) {\n        return false\n      }\n\n      const focusBlock = getFocusBlock(snapshot)\n\n      if (!focusBlock) {\n        return false\n      }\n\n      const originalTextBefore = getBlockTextBefore(snapshot)\n      let textBefore = originalTextBefore\n      const originalNewText = textBefore + event.text\n      let newText = originalNewText\n\n      const foundMatches: Array<InputRuleMatch['groupMatches'][number]> = []\n      const foundActions: Array<BehaviorAction> = []\n\n      for (const rule of config.rules) {\n        const matcher = new RegExp(rule.on.source, 'gd')\n\n        while (true) {\n          // Find matches in the text after the insertion\n          const ruleMatches = [...newText.matchAll(matcher)].flatMap(\n            (regExpMatch) => {\n              if (regExpMatch.indices === undefined) {\n                return []\n              }\n\n              const match = regExpMatch.indices.at(0)\n\n              if (!match) {\n                return []\n              }\n\n              const matchLocation = getInputRuleMatchLocation({\n                match: [regExpMatch.at(0) ?? '', ...match],\n                adjustIndexBy: originalNewText.length - newText.length,\n                snapshot,\n                focusBlock,\n                originalTextBefore,\n              })\n\n              if (!matchLocation) {\n                return []\n              }\n\n              const existsInTextBefore =\n                matchLocation.targetOffsets.focus.offset <=\n                originalTextBefore.length\n\n              // Ignore if this match occurs in the text before the insertion\n              if (existsInTextBefore) {\n                return []\n              }\n\n              const alreadyFound = foundMatches.some(\n                (foundMatch) =>\n                  foundMatch.targetOffsets.anchor.offset ===\n                  matchLocation.targetOffsets.anchor.offset,\n              )\n\n              // Ignore if this match has already been found\n              if (alreadyFound) {\n                return []\n              }\n\n              const groupMatches =\n                regExpMatch.indices.length > 1\n                  ? regExpMatch.indices\n                      .slice(1)\n                      .filter((indices) => indices !== undefined)\n                  : []\n\n              const ruleMatch = {\n                text: matchLocation.text,\n                selection: matchLocation.selection,\n                targetOffsets: matchLocation.targetOffsets,\n                groupMatches: groupMatches.flatMap((match, index) => {\n                  const text = regExpMatch.at(index + 1) ?? ''\n                  const groupMatchLocation = getInputRuleMatchLocation({\n                    match: [text, ...match],\n                    adjustIndexBy: originalNewText.length - newText.length,\n                    snapshot,\n                    focusBlock,\n                    originalTextBefore,\n                  })\n\n                  if (!groupMatchLocation) {\n                    return []\n                  }\n\n                  return groupMatchLocation\n                }),\n              }\n\n              return [ruleMatch]\n            },\n          )\n\n          if (ruleMatches.length > 0) {\n            const guardResult =\n              rule.guard?.({\n                snapshot,\n                event: {\n                  type: 'custom.input rule',\n                  matches: ruleMatches,\n                  focusBlock,\n                  textBefore: originalTextBefore,\n                  textInserted: event.text,\n                },\n                dom,\n              }) ?? true\n\n            if (!guardResult) {\n              break\n            }\n\n            const actionSets = rule.actions.map((action) =>\n              action(\n                {\n                  snapshot,\n                  event: {\n                    type: 'custom.input rule',\n                    matches: ruleMatches,\n                    focusBlock,\n                    textBefore: originalTextBefore,\n                    textInserted: event.text,\n                  },\n                  dom,\n                },\n                guardResult,\n              ),\n            )\n\n            for (const actionSet of actionSets) {\n              for (const action of actionSet) {\n                foundActions.push(action)\n              }\n            }\n\n            const matches = ruleMatches.flatMap((match) =>\n              match.groupMatches.length === 0 ? [match] : match.groupMatches,\n            )\n\n            for (const match of matches) {\n              // Remember each match and adjust `textBefore` and `newText` so\n              // no subsequent matches can overlap with this one\n              foundMatches.push(match)\n              textBefore = newText.slice(\n                0,\n                match.targetOffsets.focus.offset ?? 0,\n              )\n              newText = originalNewText.slice(\n                match.targetOffsets.focus.offset ?? 0,\n              )\n            }\n          } else {\n            // If no match was found, break out of the loop to try the next\n            // rule\n            break\n          }\n        }\n      }\n\n      if (foundActions.length === 0) {\n        return false\n      }\n\n      return {actions: foundActions}\n    },\n    actions: [\n      ({event}) => [forward(event)],\n      (_, {actions}) => actions,\n      ({snapshot}) => [\n        effect(() => {\n          const blockOffsets = getBlockOffsets(snapshot)\n\n          config.onApply?.({endOffsets: blockOffsets})\n        }),\n      ],\n    ],\n  })\n}\n\ntype InputRulePluginProps = {\n  rules: Array<InputRule<any>>\n}\n\n/**\n * Turn an array of `InputRule`s into a Behavior that can be used to apply the\n * rules to the editor.\n *\n * The plugin handles undo/redo out of the box including smart undo with\n * Backspace.\n *\n * @example\n * ```tsx\n * <InputRulePlugin rules={smartQuotesRules} />\n * ```\n *\n * @alpha\n */\nexport function InputRulePlugin(props: InputRulePluginProps) {\n  const editor = useEditor()\n\n  useActorRef(inputRuleMachine, {\n    input: {editor, rules: props.rules},\n  })\n\n  return null\n}\n\ntype InputRuleMachineEvent =\n  | {\n      type: 'input rule raised'\n      endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n    }\n  | {type: 'history.undo raised'}\n  | {\n      type: 'selection changed'\n      blockOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n    }\n\nconst inputRuleListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {\n    editor: Editor\n    rules: Array<InputRule>\n  }\n> = ({input, sendBack}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineInputRuleBehavior({\n      rules: input.rules,\n      onApply: ({endOffsets}) => {\n        sendBack({type: 'input rule raised', endOffsets})\n      },\n    }),\n  })\n\n  return () => {\n    unregister()\n  }\n}\n\nconst deleteBackwardListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {editor: Editor}\n> = ({input, sendBack}) => {\n  return input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'delete.backward',\n      actions: [\n        () => [\n          raise({type: 'history.undo'}),\n          effect(() => {\n            sendBack({type: 'history.undo raised'})\n          }),\n        ],\n      ],\n    }),\n  })\n}\n\nconst selectionListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'select',\n      guard: ({snapshot, event}) => {\n        const blockOffsets = getBlockOffsets({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.at,\n          },\n        })\n\n        return {blockOffsets}\n      },\n      actions: [\n        ({event}, {blockOffsets}) => [\n          effect(() => {\n            sendBack({type: 'selection changed', blockOffsets})\n          }),\n          forward(event),\n        ],\n      ],\n    }),\n  })\n\n  return unregister\n}\n\nconst inputRuleSetup = setup({\n  types: {\n    context: {} as {\n      editor: Editor\n      rules: Array<InputRule>\n      endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n    },\n    input: {} as {\n      editor: Editor\n      rules: Array<InputRule>\n    },\n    events: {} as InputRuleMachineEvent,\n  },\n  actors: {\n    'delete.backward listener': fromCallback(deleteBackwardListenerCallback),\n    'input rule listener': fromCallback(inputRuleListenerCallback),\n    'selection listener': fromCallback(selectionListenerCallback),\n  },\n  guards: {\n    'block offset changed': ({context, event}) => {\n      if (event.type !== 'selection changed') {\n        return false\n      }\n\n      if (!event.blockOffsets || !context.endOffsets) {\n        return true\n      }\n\n      const startChanged =\n        context.endOffsets.start.path[0]._key !==\n          event.blockOffsets.start.path[0]._key ||\n        context.endOffsets.start.offset !== event.blockOffsets.start.offset\n      const endChanged =\n        context.endOffsets.end.path[0]._key !==\n          event.blockOffsets.end.path[0]._key ||\n        context.endOffsets.end.offset !== event.blockOffsets.end.offset\n\n      return startChanged || endChanged\n    },\n  },\n})\n\nconst assignEndOffsets = inputRuleSetup.assign({\n  endOffsets: ({context, event}) =>\n    event.type === 'input rule raised' ? event.endOffsets : context.endOffsets,\n})\n\nconst inputRuleMachine = inputRuleSetup.createMachine({\n  id: 'input rule',\n  context: ({input}) => ({\n    editor: input.editor,\n    rules: input.rules,\n    endOffsets: undefined,\n  }),\n  initial: 'idle',\n  invoke: {\n    src: 'input rule listener',\n    input: ({context}) => ({\n      editor: context.editor,\n      rules: context.rules,\n    }),\n  },\n  on: {\n    'input rule raised': {\n      target: '.input rule applied',\n      actions: assignEndOffsets,\n    },\n  },\n  states: {\n    'idle': {},\n    'input rule applied': {\n      invoke: [\n        {\n          src: 'delete.backward listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n        {\n          src: 'selection listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n      ],\n      on: {\n        'selection changed': {\n          target: 'idle',\n          guard: 'block offset changed',\n        },\n        'history.undo raised': {\n          target: 'idle',\n        },\n      },\n    },\n  },\n})\n","import {raise, type BehaviorAction} from '@portabletext/editor/behaviors'\nimport {getMarkState} from '@portabletext/editor/selectors'\nimport type {InputRule, InputRuleGuard} from './input-rule'\nimport type {InputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * @alpha\n */\nexport type TextTransformRule<TGuardResponse = true> = {\n  on: RegExp\n  guard?: InputRuleGuard<TGuardResponse>\n  transform: (\n    {location}: {location: InputRuleMatchLocation},\n    guardResponse: TGuardResponse,\n  ) => string\n}\n\n/**\n * Define an `InputRule` specifically designed to transform matched text into\n * some other text.\n *\n * @example\n * ```tsx\n * const transformRule = defineTextTransformRule({\n *   on: /--/,\n *   transform: () => '',\n * })\n * ```\n *\n * @alpha\n */\nexport function defineTextTransformRule<TGuardResponse = true>(\n  config: TextTransformRule<TGuardResponse>,\n): InputRule<TGuardResponse> {\n  return {\n    on: config.on,\n    guard: config.guard ?? (() => true as TGuardResponse),\n    actions: [\n      ({snapshot, event}, guardResponse) => {\n        const locations = event.matches.flatMap((match) =>\n          match.groupMatches.length === 0 ? [match] : match.groupMatches,\n        )\n        const newText = event.textBefore + event.textInserted\n\n        let textLengthDelta = 0\n        const actions: Array<BehaviorAction> = []\n\n        for (const location of locations.reverse()) {\n          const text = config.transform({location}, guardResponse)\n\n          textLengthDelta =\n            textLengthDelta -\n            (text.length -\n              (location.targetOffsets.focus.offset -\n                location.targetOffsets.anchor.offset))\n\n          actions.push(raise({type: 'select', at: location.targetOffsets}))\n          actions.push(raise({type: 'delete', at: location.targetOffsets}))\n          actions.push(\n            raise({\n              type: 'insert.child',\n              child: {\n                _type: snapshot.context.schema.span.name,\n                text,\n                marks:\n                  getMarkState({\n                    ...snapshot,\n                    context: {\n                      ...snapshot.context,\n                      selection: {\n                        anchor: location.selection.anchor,\n                        focus: {\n                          path: location.selection.focus.path,\n                          offset: Math.min(\n                            location.selection.focus.offset,\n                            event.textBefore.length,\n                          ),\n                        },\n                      },\n                    },\n                  })?.marks ?? [],\n              },\n            }),\n          )\n        }\n\n        const endCaretPosition = {\n          path: event.focusBlock.path,\n          offset: newText.length - textLengthDelta,\n        }\n\n        return [\n          ...actions,\n          raise({\n            type: 'select',\n            at: {\n              anchor: endCaretPosition,\n              focus: endCaretPosition,\n            },\n          }),\n        ]\n      },\n    ],\n  }\n}\n"],"names":["defineInputRule","config","getInputRuleMatchLocation","match","adjustIndexBy","snapshot","focusBlock","originalTextBefore","text","start","end","adjustedIndex","targetOffsets","anchor","path","offset","focus","backward","normalizedOffsets","Math","min","length","anchorBackwards","blockOffsetToSpanSelectionPoint","context","blockOffset","direction","focusForwards","selection","inlineObjectsAfterMatch","getNextInlineObjects","inlineObjectsBefore","getPreviousInlineObjects","some","inlineObjectAfter","inlineObjectBefore","node","_key","defineInputRuleBehavior","defineBehavior","on","guard","event","dom","isSelectionCollapsed","getFocusBlock","getBlockTextBefore","textBefore","originalNewText","newText","foundMatches","foundActions","rule","rules","matcher","RegExp","source","ruleMatches","matchAll","flatMap","regExpMatch","indices","undefined","at","matchLocation","foundMatch","groupMatches","slice","filter","index","guardResult","type","matches","textInserted","actionSets","actions","map","action","actionSet","push","forward","_","effect","blockOffsets","getBlockOffsets","onApply","endOffsets","InputRulePlugin","props","$","_c","editor","useEditor","t0","input","useActorRef","inputRuleMachine","inputRuleListenerCallback","sendBack","unregister","registerBehavior","behavior","deleteBackwardListenerCallback","raise","selectionListenerCallback","inputRuleSetup","setup","types","events","actors","fromCallback","guards","block offset changed","startChanged","endChanged","assignEndOffsets","assign","createMachine","id","initial","invoke","src","target","states","defineTextTransformRule","guardResponse","locations","textLengthDelta","location","reverse","transform","child","_type","schema","span","name","marks","getMarkState","endCaretPosition"],"mappings":"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"}},
    {"offset": {"line": 4192, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-markdown-shortcuts/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/behavior.markdown-shortcuts.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.blockquote.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.heading.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.horizontal-rule.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.markdown-link.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.ordered-list.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.unordered-list.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-markdown-shortcuts/src/plugin.markdown-shortcuts.tsx"],"sourcesContent":["import type {EditorContext} from '@portabletext/editor'\nimport {defineBehavior, raise} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\n\nexport type ObjectWithOptionalKey = {\n  _type: string\n  _key?: string\n  [other: string]: unknown\n}\n\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: ({\n    context,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n  }) => ObjectWithOptionalKey | undefined\n  defaultStyle?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}\n\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticHrOnPaste = defineBehavior({\n    on: 'clipboard.paste',\n    guard: ({snapshot, event}) => {\n      const text = event.originEvent.dataTransfer.getData('text/plain')\n      const hrRegExp = /^(---)$|^(-)$|^(___)$|^(\\*\\*\\*)$/\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.({\n        context: {\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n        },\n      })\n      const focusBlock = selectors.getFocusBlock(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock, focusTextBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        raise({\n          type: 'insert.text',\n          text: hrCharacters,\n        }),\n      ],\n      ({snapshot}, {hrObject, focusBlock, focusTextBlock}) =>\n        focusTextBlock\n          ? [\n              raise({\n                type: 'insert.block',\n                block: {\n                  _type: snapshot.context.schema.block.name,\n                  children: focusTextBlock.node.children,\n                },\n                placement: 'after',\n              }),\n              raise({\n                type: 'insert.block',\n                block: hrObject,\n                placement: 'after',\n              }),\n              raise({\n                type: 'delete.block',\n                at: focusBlock.path,\n              }),\n            ]\n          : [\n              raise({\n                type: 'insert.block',\n                block: hrObject,\n                placement: 'after',\n              }),\n            ],\n    ],\n  })\n\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({snapshot}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        snapshot.context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        raise({\n          type: 'block.set',\n          props: {style: defaultStyle},\n          at: focusTextBlock.path,\n        }),\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [automaticHrOnPaste, clearStyleOnBackspace]\n\n  return markdownBehaviors\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createBlockquoteRule(config: {\n  blockquoteStyle: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^> /,\n    guard: ({snapshot, event}) => {\n      const style = config.blockquoteStyle({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (!style) {\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {style, match}\n    },\n    actions: [\n      ({event}, {style, match}) => [\n        raise({\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {style},\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createHeadingRule(config: {\n  headingStyle: ({\n    context,\n    schema,\n    props,\n    level,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n    props: {level: number}\n    /**\n     * @deprecated Use `props.level` instead\n     */\n    level: number\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^#+ /,\n    guard: ({snapshot, event}) => {\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      const level = match.text.length - 1\n\n      const style = config.headingStyle({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n        props: {level},\n        level,\n      })\n\n      if (!style) {\n        return false\n      }\n\n      return {match, style}\n    },\n    actions: [\n      ({event}, {match, style}) => [\n        raise({\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {style},\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\nimport type {ObjectWithOptionalKey} from './behavior.markdown-shortcuts'\n\nexport function createHorizontalRuleRule(config: {\n  horizontalRuleObject: ({\n    context,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n  }) => ObjectWithOptionalKey | undefined\n}) {\n  return defineInputRule({\n    on: /^(---)|^(-)|^(___)|^(\\*\\*\\*)/,\n    guard: ({snapshot, event}) => {\n      const hrObject = config.horizontalRuleObject({\n        context: {\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n        },\n      })\n\n      if (!hrObject) {\n        // If no horizontal rule object is provided, then we can safely skip\n        // this rule.\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        // Input Rules only look at the plain text of the text block. This\n        // means that the RegExp is matched even if there is a leading inline\n        // object.\n        return false\n      }\n\n      // In theory, an Input Rule could return multiple matches. But in this\n      // case we only expect one match.\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {hrObject, match}\n    },\n    actions: [\n      (_, {hrObject, match}) => [\n        raise({\n          type: 'insert.block',\n          block: hrObject,\n          placement: 'before',\n          select: 'none',\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise, type BehaviorAction} from '@portabletext/editor/behaviors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\nimport type {ObjectWithOptionalKey} from './behavior.markdown-shortcuts'\n\nexport function createMarkdownLinkRule(config: {\n  linkObject: ({\n    context,\n    props,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n    props: {href: string}\n  }) => ObjectWithOptionalKey | undefined\n}) {\n  return defineInputRule({\n    on: /\\[([^[\\]]+)]\\((.+)\\)/,\n    actions: [\n      ({snapshot, event}) => {\n        const newText = event.textBefore + event.textInserted\n        let textLengthDelta = 0\n        const actions: Array<BehaviorAction> = []\n\n        for (const match of event.matches.reverse()) {\n          const textMatch = match.groupMatches.at(0)\n          const hrefMatch = match.groupMatches.at(1)\n\n          if (textMatch === undefined || hrefMatch === undefined) {\n            continue\n          }\n\n          textLengthDelta =\n            textLengthDelta -\n            (match.targetOffsets.focus.offset -\n              match.targetOffsets.anchor.offset -\n              textMatch.text.length)\n\n          const linkObject = config.linkObject({\n            context: {\n              schema: snapshot.context.schema,\n              keyGenerator: snapshot.context.keyGenerator,\n            },\n            props: {href: hrefMatch.text},\n          })\n\n          if (!linkObject) {\n            continue\n          }\n\n          const {_type, _key, ...value} = linkObject\n\n          const leftSideOffsets = {\n            anchor: match.targetOffsets.anchor,\n            focus: textMatch.targetOffsets.anchor,\n          }\n          const rightSideOffsets = {\n            anchor: textMatch.targetOffsets.focus,\n            focus: match.targetOffsets.focus,\n          }\n\n          actions.push(\n            raise({\n              type: 'select',\n              at: textMatch.targetOffsets,\n            }),\n          )\n          actions.push(\n            raise({\n              type: 'annotation.add',\n              annotation: {\n                name: _type,\n                _key,\n                value,\n              },\n            }),\n          )\n          actions.push(\n            raise({\n              type: 'delete',\n              at: rightSideOffsets,\n            }),\n          )\n          actions.push(\n            raise({\n              type: 'delete',\n              at: leftSideOffsets,\n            }),\n          )\n        }\n\n        const endCaretPosition = {\n          path: event.focusBlock.path,\n          offset: newText.length - textLengthDelta * -1,\n        }\n\n        return [\n          ...actions,\n          raise({\n            type: 'select',\n            at: {\n              anchor: endCaretPosition,\n              focus: endCaretPosition,\n            },\n          }),\n        ]\n      },\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createOrderedListRule(config: {\n  orderedList: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^1\\. /,\n    guard: ({snapshot, event}) => {\n      const orderedList = config.orderedList({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (!orderedList) {\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {match, orderedList}\n    },\n    actions: [\n      ({event}, {match, orderedList}) => [\n        raise({\n          type: 'block.unset',\n          props: ['style'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {\n            listItem: orderedList,\n            level: event.focusBlock.node.level ?? 1,\n          },\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createUnorderedListRule(config: {\n  unorderedList: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^(-|\\*) /,\n    guard: ({snapshot, event}) => {\n      const unorderedList = config.unorderedList({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (!unorderedList) {\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {match, unorderedList}\n    },\n    actions: [\n      ({event}, {match, unorderedList}) => [\n        raise({\n          type: 'block.unset',\n          props: ['style'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {\n            listItem: unorderedList,\n            level: event.focusBlock.node.level ?? 1,\n          },\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {useEditor} from '@portabletext/editor'\nimport {CharacterPairDecoratorPlugin} from '@portabletext/plugin-character-pair-decorator'\nimport {InputRulePlugin} from '@portabletext/plugin-input-rule'\nimport {useEffect, useMemo} from 'react'\nimport {\n  createMarkdownBehaviors,\n  type MarkdownBehaviorsConfig,\n  type ObjectWithOptionalKey,\n} from './behavior.markdown-shortcuts'\nimport {createBlockquoteRule} from './rule.blockquote'\nimport {createHeadingRule} from './rule.heading'\nimport {createHorizontalRuleRule} from './rule.horizontal-rule'\nimport {createMarkdownLinkRule} from './rule.markdown-link'\nimport {createOrderedListRule} from './rule.ordered-list'\nimport {createUnorderedListRule} from './rule.unordered-list'\n\n/**\n * @public\n */\nexport type MarkdownShortcutsPluginProps = MarkdownBehaviorsConfig & {\n  blockquoteStyle?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  defaultStyle?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  headingStyle?: ({\n    context,\n    schema,\n    props,\n    level,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n    props: {level: number}\n    /**\n     * @deprecated Use `props.level` instead\n     */\n    level: number\n  }) => string | undefined\n  linkObject?: ({\n    context,\n    props,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n    props: {href: string}\n  }) => ObjectWithOptionalKey | undefined\n  unorderedList?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  orderedList?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  boldDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  codeDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  italicDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  strikeThroughDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}\n\n/**\n * @public\n */\nexport function MarkdownShortcutsPlugin({\n  blockquoteStyle,\n  boldDecorator,\n  codeDecorator,\n  defaultStyle,\n  headingStyle,\n  horizontalRuleObject,\n  linkObject,\n  italicDecorator,\n  orderedList,\n  strikeThroughDecorator,\n  unorderedList,\n}: MarkdownShortcutsPluginProps) {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const behaviors = createMarkdownBehaviors({\n      defaultStyle,\n    })\n\n    const unregisterBehaviors = behaviors.map((behavior) =>\n      editor.registerBehavior({behavior}),\n    )\n\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors) {\n        unregisterBehavior()\n      }\n    }\n  }, [defaultStyle, editor])\n\n  const inputRules = useMemo(() => {\n    const rules = []\n    if (blockquoteStyle) {\n      rules.push(createBlockquoteRule({blockquoteStyle}))\n    }\n    if (headingStyle) {\n      rules.push(createHeadingRule({headingStyle}))\n    }\n    if (horizontalRuleObject) {\n      rules.push(createHorizontalRuleRule({horizontalRuleObject}))\n    }\n    if (linkObject) {\n      rules.push(createMarkdownLinkRule({linkObject}))\n    }\n    if (orderedList) {\n      rules.push(createOrderedListRule({orderedList}))\n    }\n    if (unorderedList) {\n      rules.push(createUnorderedListRule({unorderedList}))\n    }\n    return rules.length > 0 ? rules : null\n  }, [\n    blockquoteStyle,\n    headingStyle,\n    horizontalRuleObject,\n    linkObject,\n    orderedList,\n    unorderedList,\n  ])\n\n  return (\n    <>\n      {boldDecorator ? (\n        <>\n          <CharacterPairDecoratorPlugin\n            decorator={boldDecorator}\n            pair={{char: '*', amount: 2}}\n          />\n          <CharacterPairDecoratorPlugin\n            decorator={boldDecorator}\n            pair={{char: '_', amount: 2}}\n          />\n        </>\n      ) : null}\n      {codeDecorator ? (\n        <CharacterPairDecoratorPlugin\n          decorator={codeDecorator}\n          pair={{char: '`', amount: 1}}\n        />\n      ) : null}\n      {italicDecorator ? (\n        <>\n          <CharacterPairDecoratorPlugin\n            decorator={italicDecorator}\n            pair={{char: '*', amount: 1}}\n          />\n          <CharacterPairDecoratorPlugin\n            decorator={italicDecorator}\n            pair={{char: '_', amount: 1}}\n          />\n        </>\n      ) : null}\n      {strikeThroughDecorator ? (\n        <CharacterPairDecoratorPlugin\n          decorator={strikeThroughDecorator}\n          pair={{char: '~', amount: 2}}\n        />\n      ) : null}\n      {inputRules ? <InputRulePlugin rules={inputRules} /> : null}\n    </>\n  )\n}\n"],"names":["createMarkdownBehaviors","config","automaticHrOnPaste","defineBehavior","on","guard","snapshot","event","text","originEvent","dataTransfer","getData","hrRegExp","hrCharacters","match","hrObject","horizontalRuleObject","context","schema","keyGenerator","focusBlock","selectors","getFocusBlock","focusTextBlock","getFocusTextBlock","actions","_","raise","type","block","_type","name","children","node","placement","at","path","clearStyleOnBackspace","selectionCollapsed","isSelectionCollapsed","focusSpan","getFocusSpan","atTheBeginningOfBLock","_key","selection","focus","offset","defaultStyle","style","props","createBlockquoteRule","defineInputRule","blockquoteStyle","getPreviousInlineObject","matches","targetOffsets","createHeadingRule","level","length","headingStyle","createHorizontalRuleRule","select","createMarkdownLinkRule","newText","textBefore","textInserted","textLengthDelta","reverse","textMatch","groupMatches","hrefMatch","undefined","anchor","linkObject","href","value","leftSideOffsets","rightSideOffsets","push","annotation","endCaretPosition","createOrderedListRule","orderedList","listItem","createUnorderedListRule","unorderedList","MarkdownShortcutsPlugin","t0","$","_c","boldDecorator","codeDecorator","italicDecorator","strikeThroughDecorator","editor","useEditor","t1","t2","unregisterBehaviors","map","behavior","registerBehavior","unregisterBehavior","useEffect","rules","t3","inputRules","char","amount","t4","t5","t6","t7","t8"],"mappings":"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"}},
    {"offset": {"line": 4699, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-typography/dist/index.js","sources":["file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-typography/src/create-decorator-guard.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-typography/src/input-rules.typography.ts","file:///C:/xampp/htdocs/sites/paginas/blogs/node_modules/%40portabletext/plugin-typography/src/plugin.typography.tsx"],"sourcesContent":["import type {EditorContext, EditorSchema} from '@portabletext/editor'\nimport {\n  getSelectedSpans,\n  isActiveDecorator,\n} from '@portabletext/editor/selectors'\nimport type {InputRuleGuard} from '@portabletext/plugin-input-rule'\n\n/**\n * @public\n * Create an `InputRuleGuard` that can prevent the rule from running inside\n * certain decorators.\n *\n * @example\n * ```tsx\n * const guard = createDecoratorGuard({\n *  decorators: ({context}) => context.schema.decorators.flatMap((decorator) => decorator.name === 'code' ? [] : [decorator.name]),\n * })\n *\n * <TypographyPlugin guard={guard} />\n * ```\n */\nexport function createDecoratorGuard(config: {\n  decorators: ({\n    context,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n  }) => Array<EditorSchema['decorators'][number]['name']>\n}): InputRuleGuard {\n  return ({snapshot, event}) => {\n    const allowedDecorators = config.decorators({\n      context: {\n        schema: snapshot.context.schema,\n      },\n    })\n    const decorators = snapshot.context.schema.decorators.flatMap(\n      (decorator) =>\n        allowedDecorators.includes(decorator.name) ? [] : [decorator.name],\n    )\n\n    if (decorators.length === 0) {\n      return true\n    }\n\n    const matchedSpans = event.matches.flatMap((match) =>\n      getSelectedSpans({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: match.selection,\n        },\n      }),\n    )\n\n    let preventInputRule = false\n\n    for (const decorator of decorators) {\n      if (isActiveDecorator(decorator)(snapshot)) {\n        preventInputRule = true\n        break\n      }\n\n      if (matchedSpans.some((span) => span.node.marks?.includes(decorator))) {\n        preventInputRule = true\n        break\n      }\n    }\n\n    return !preventInputRule\n  }\n}\n","import {\n  defineTextTransformRule,\n  type InputRule,\n} from '@portabletext/plugin-input-rule'\n\n/**\n * @public\n */\nexport const emDashRule = defineTextTransformRule({\n  on: /--/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const ellipsisRule = defineTextTransformRule({\n  on: /\\.\\.\\./,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const openingDoubleQuoteRule = defineTextTransformRule({\n  on: /(?:^|(?<=[\\s{[(<'\"\\u2018\\u201C]))\"/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const closingDoubleQuoteRule = defineTextTransformRule({\n  on: /\"/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const openingSingleQuoteRule = defineTextTransformRule({\n  on: /(?:^|(?<=[\\s{[(<'\"\\u2018\\u201C]))'/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const closingSingleQuoteRule = defineTextTransformRule({\n  on: /'/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const smartQuotesRules: Array<InputRule> = [\n  openingDoubleQuoteRule,\n  closingDoubleQuoteRule,\n  openingSingleQuoteRule,\n  closingSingleQuoteRule,\n]\n\n/**\n * @public\n */\nexport const leftArrowRule = defineTextTransformRule({\n  on: /<-/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const rightArrowRule = defineTextTransformRule({\n  on: /->/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const copyrightRule = defineTextTransformRule({\n  on: /\\(c\\)/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const servicemarkRule = defineTextTransformRule({\n  on: /\\(sm\\)/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const trademarkRule = defineTextTransformRule({\n  on: /\\(tm\\)/,\n  transform: () => '',\n})\n\n/**\n * @beta\n */\nexport const registeredTrademarkRule = defineTextTransformRule({\n  on: /\\(r\\)/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const oneHalfRule = defineTextTransformRule({\n  on: /(?:^|\\s)(1\\/2)\\s/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const plusMinusRule = defineTextTransformRule({\n  on: /\\+\\/-/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const notEqualRule = defineTextTransformRule({\n  on: /!=/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const laquoRule = defineTextTransformRule({\n  on: /<</,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const raquoRule = defineTextTransformRule({\n  on: />>/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const multiplicationRule = defineTextTransformRule({\n  on: /\\d+\\s?([*x])\\s?\\d+/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const superscriptTwoRule = defineTextTransformRule({\n  on: /\\^2/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const superscriptThreeRule = defineTextTransformRule({\n  on: /\\^3/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const oneQuarterRule = defineTextTransformRule({\n  on: /(?:^|\\s)(1\\/4)\\s/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const threeQuartersRule = defineTextTransformRule({\n  on: /(?:^|\\s)(3\\/4)\\s/,\n  transform: () => '',\n})\n","import {\n  InputRulePlugin,\n  type InputRuleGuard,\n} from '@portabletext/plugin-input-rule'\nimport {useMemo} from 'react'\nimport {\n  closingDoubleQuoteRule,\n  closingSingleQuoteRule,\n  copyrightRule,\n  ellipsisRule,\n  emDashRule,\n  laquoRule,\n  leftArrowRule,\n  multiplicationRule,\n  notEqualRule,\n  oneHalfRule,\n  oneQuarterRule,\n  openingDoubleQuoteRule,\n  openingSingleQuoteRule,\n  plusMinusRule,\n  raquoRule,\n  registeredTrademarkRule,\n  rightArrowRule,\n  servicemarkRule,\n  superscriptThreeRule,\n  superscriptTwoRule,\n  threeQuartersRule,\n  trademarkRule,\n} from './input-rules.typography'\n\nconst defaultRuleConfig = [\n  {name: 'emDash', rule: emDashRule, state: 'on'},\n  {name: 'ellipsis', rule: ellipsisRule, state: 'on'},\n  {name: 'openingDoubleQuote', rule: openingDoubleQuoteRule, state: 'on'},\n  {name: 'closingDoubleQuote', rule: closingDoubleQuoteRule, state: 'on'},\n  {name: 'openingSingleQuote', rule: openingSingleQuoteRule, state: 'on'},\n  {name: 'closingSingleQuote', rule: closingSingleQuoteRule, state: 'on'},\n  {name: 'leftArrow', rule: leftArrowRule, state: 'on'},\n  {name: 'rightArrow', rule: rightArrowRule, state: 'on'},\n  {name: 'copyright', rule: copyrightRule, state: 'on'},\n  {name: 'trademark', rule: trademarkRule, state: 'on'},\n  {name: 'servicemark', rule: servicemarkRule, state: 'on'},\n  {name: 'registeredTrademark', rule: registeredTrademarkRule, state: 'on'},\n  {name: 'oneHalf', rule: oneHalfRule, state: 'off'},\n  {name: 'plusMinus', rule: plusMinusRule, state: 'off'},\n  {name: 'laquo', rule: laquoRule, state: 'off'},\n  {name: 'notEqual', rule: notEqualRule, state: 'off'},\n  {name: 'raquo', rule: raquoRule, state: 'off'},\n  {name: 'multiplication', rule: multiplicationRule, state: 'off'},\n  {name: 'superscriptTwo', rule: superscriptTwoRule, state: 'off'},\n  {name: 'superscriptThree', rule: superscriptThreeRule, state: 'off'},\n  {name: 'oneQuarter', rule: oneQuarterRule, state: 'off'},\n  {name: 'threeQuarters', rule: threeQuartersRule, state: 'off'},\n] as const\n\ntype RuleName = (typeof defaultRuleConfig)[number]['name']\n\n/**\n * @public\n */\nexport type TypographyPluginProps<\n  TEnabledRuleName extends RuleName = never,\n  TDisabledRuleName extends Exclude<RuleName, TEnabledRuleName> = never,\n> = {\n  guard?: InputRuleGuard\n  /**\n   * Preset configuration for rules.\n   * - `'default'`: Common typography rules enabled (em dash, ellipsis, quotes, arrows, copyright symbols)\n   * - `'all'`: All rules enabled\n   * - `'none'`: No rules enabled (use with `enable` prop)\n   *\n   * @defaultValue 'default'\n   */\n  preset?: 'default' | 'all' | 'none'\n  /**\n   * Enable specific rules (additive to preset).\n   * Use this to enable additional rules beyond the preset.\n   *\n   * @example\n   * ```tsx\n   * // Enable multiplication and plusMinus in addition to default rules\n   * <TypographyPlugin enable={['multiplication', 'plusMinus']} />\n   * ```\n   */\n  enable?: ReadonlyArray<TEnabledRuleName>\n  /**\n   * Disable specific rules (subtractive from preset).\n   * Use this to disable rules that would otherwise be enabled by the preset.\n   * Cannot contain rules that are in the `enable` array (TypeScript will enforce this).\n   *\n   * @example\n   * ```tsx\n   * // Disable em dash from the default rules\n   * <TypographyPlugin disable={['emDash']} />\n   * ```\n   */\n  disable?: ReadonlyArray<TDisabledRuleName>\n}\n\n/**\n * @public\n */\nexport function TypographyPlugin<\n  TEnabledRuleName extends RuleName = never,\n  TDisabledRuleName extends Exclude<RuleName, TEnabledRuleName> = never,\n>(props: TypographyPluginProps<TEnabledRuleName, TDisabledRuleName>) {\n  const {preset = 'default', enable = [], disable = [], guard} = props\n\n  const configuredInputRules = useMemo(() => {\n    // Determine which rules should be enabled based on preset\n    const enabledRules = new Set<RuleName>()\n\n    if (preset === 'all') {\n      // Enable all rules\n      for (const rule of defaultRuleConfig) {\n        enabledRules.add(rule.name)\n      }\n    } else if (preset === 'default') {\n      // Enable only default rules (state: 'on')\n      for (const rule of defaultRuleConfig) {\n        if (rule.state === 'on') {\n          enabledRules.add(rule.name)\n        }\n      }\n    }\n    // preset === 'none' starts with empty set\n\n    // Apply enable list (additive)\n    for (const ruleName of enable) {\n      enabledRules.add(ruleName)\n    }\n\n    // Apply disable list (subtractive)\n    for (const ruleName of disable) {\n      enabledRules.delete(ruleName)\n    }\n\n    // Build final rule list\n    return defaultRuleConfig.flatMap((rule) =>\n      enabledRules.has(rule.name)\n        ? [{...rule.rule, guard: guard ?? (() => true)}]\n        : [],\n    )\n  }, [preset, enable, disable, guard])\n\n  return <InputRulePlugin rules={configuredInputRules} />\n}\n"],"names":["createDecoratorGuard","config","snapshot","event","allowedDecorators","decorators","context","schema","flatMap","decorator","includes","name","length","matchedSpans","matches","match","getSelectedSpans","selection","preventInputRule","isActiveDecorator","some","span","node","marks","emDashRule","defineTextTransformRule","on","transform","ellipsisRule","openingDoubleQuoteRule","closingDoubleQuoteRule","openingSingleQuoteRule","closingSingleQuoteRule","smartQuotesRules","leftArrowRule","rightArrowRule","copyrightRule","servicemarkRule","trademarkRule","registeredTrademarkRule","oneHalfRule","plusMinusRule","notEqualRule","laquoRule","raquoRule","multiplicationRule","superscriptTwoRule","superscriptThreeRule","oneQuarterRule","threeQuartersRule","defaultRuleConfig","rule","state","TypographyPlugin","props","$","_c","preset","t0","enable","t1","disable","t2","guard","undefined","t3","t4","enabledRules","Set","add","rule_0","ruleName","ruleName_0","delete","t5","rule_1","has","_temp","configuredInputRules","t6"],"mappings":"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"}}]
}